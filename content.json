{"meta":{"title":"WhiteのBlog","subtitle":"欢迎ヾ(≧▽≦*)o","description":"Nothing is impossible","author":"WhiteCells","url":"https://www.030215.xyz","root":"/"},"pages":[{"title":"关于","date":"2023-02-08T07:20:15.747Z","updated":"2023-02-08T07:20:15.747Z","comments":true,"path":"about/index.html","permalink":"https://www.030215.xyz/about/index.html","excerpt":"","text":"这里是这个网站的相关内容 本站基于 hexo 框架搭建，主题butterfly在此基础上进行修改，采用双线部署 本站没有进行备案相关操作（太麻烦了╯︿╰） 本站没有进行国内的 CDN 服务（没备案 本站没有进行搜索引擎收录（暂时没必要 本站没有植入广告内容，放心食用(￣y▽￣)╭ Ohohoho…..） 站点网址：030215.xyz 站点备用网址：xuan5123.eu.org（稳定"},{"title":"归档","date":"2023-02-08T07:21:48.589Z","updated":"2023-02-08T07:21:48.589Z","comments":true,"path":"archives/index.html","permalink":"https://www.030215.xyz/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-08T07:21:07.817Z","updated":"2023-02-08T07:21:07.817Z","comments":true,"path":"categories/index.html","permalink":"https://www.030215.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-01T07:31:04.924Z","updated":"2023-02-01T07:31:04.924Z","comments":true,"path":"css/progress_bar.css","permalink":"https://www.030215.xyz/css/progress_bar.css","excerpt":"","text":".pace { -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; z-index: 2000; position: fixed; margin: auto; top: 10px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 4rem; background: #eaecf2; border: 1px #e3e8f7; overflow: hidden; } .pace-inactive .pace-progress { opacity: 0; transition: 0.3s ease-in; } .pace .pace-progress { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); -o-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); max-width: 200px; position: absolute; z-index: 2000; display: block; top: 0; right: 100%; height: 100%; width: 100%; background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab); animation: gradient 1.5s ease infinite; background-size: 200%; } .pace.pace-inactive { opacity: 0; transition: 0.3s; top: -8px; } @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } .loading-img { background: url(https://s1.vika.cn/space/2023/01/29/dafe1b1278d4468c8a65a88962ed0195) no-repeat center center; background-size: cover; }"},{"title":"","date":"2023-01-31T04:32:53.998Z","updated":"2023-01-31T04:32:53.998Z","comments":true,"path":"js/title.js","permalink":"https://www.030215.xyz/js/title.js","excerpt":"","text":"//动态标题 var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { //离开当前页面时标签显示内容 document.title = '(＞﹏＜)别走呀'; clearTimeout(titleTime); } else { //返回当前页面时标签显示内容 document.title = '(=•ω＜=)☆回来了'; //两秒后变回正常标题 titleTime = setTimeout(function () { document.title = OriginTitile; }, 1000); } });"},{"title":"链接","date":"2023-02-08T06:55:08.137Z","updated":"2023-02-08T06:55:08.137Z","comments":true,"path":"friends/index.html","permalink":"https://www.030215.xyz/friends/index.html","excerpt":"链接","text":"链接 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2023-02-08T04:57:09.328Z","updated":"2023-02-08T04:57:09.328Z","comments":true,"path":"css/custom.css","permalink":"https://www.030215.xyz/css/custom.css","excerpt":"","text":"/* 样式 */ :root { --trans-light: rgb(255 255 255 / 0%); /*最后一个数透明值*/ /* --trans-dark: rgba(25, 25, 25, 0.88); */ /* --border-style: 1px solid rgb(169, 169, 169); */ /* --backdrop-filter: blur(5px) saturate(150%); */ /* 背景过滤器，如blur(5px) saturate(150%)表示饱和度为150%的、高斯模糊半径为5px的过滤器，这是亚克力效果的一种实现方法; */ } /* 首页文章卡片 */ #recent-posts>.recent-post-item { background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ border-radius: 35px !important; /* border: var(--border-style); */ } /* 首页侧栏卡片 */ #aside-content .card-widget { background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ border-radius: 35px !important; /* border: var(--border-style); */ } /* 文章页、归档页、普通页面、分类、标签 */ div#post, div#page, div#archive, div#categories, div#category, div#tag { background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ /* border: var(--border-style); */ border-radius: 35px !important; } /* 导航栏 */ #page-header.nav-fixed #nav { background: rgba(255, 255, 255, 0) !important; /* backdrop-filter: var(--backdrop-filter); */ } /* [data-theme=\"dark\"] #page-header.nav-fixed #nav { background: rgba(0, 0, 0, 0.7) !important; } */ /* 夜间模式遮罩 */ /* [data-theme=\"dark\"] #recent-posts>.recent-post-item, [data-theme=\"dark\"] #aside-content .card-widget, [data-theme=\"dark\"] div#post, [data-theme=\"dark\"] div#archive, [data-theme=\"dark\"] div#page, [data-theme=\"dark\"] div#category, [data-theme=\"dark\"] div#tag { background: var(--trans-dark); } */ /* 页脚与头图透明 */ #footer { background: transparent !important; } /* #page-header { background: transparent !important; } */ /* 白天模式遮罩透明 */ #footer::before { background: transparent !important; } /* #page-header::before { background: transparent !important; } */ /* 夜间模式遮罩透明 */ /* [data-theme=\"dark\"] #footer::before { background: transparent !important; } [data-theme=\"dark\"] #page-header::before { background: transparent !important; } */ /* 右侧功能键 */ #rightside>div>a, #rightside>div>button { background-color: #49b1f500 !important; color: #fff !important; } :root { /* 滑动条颜色 */ /* --scrollbar-color: #15161600 !important; */ /* 字体颜色 */ --font-color: #000000 !important; /* 引用颜色 */ --blockquote-color: #000000 !important; /* 引用背景颜色 */ --blockquote-bg: rgb(0 0 0 / 10%) !important; /* 搜索的标题颜色 */ --search-result-title: #ffffff !important; /* 手机版侧边栏颜色 */ --sidebar-bg: #a7a2a18f !important; /* 按钮按下去颜色 */ --btn-hover-color: #bdc1dc !important; } /* 状态栏居中 */ /* 一级菜单居中 */ /* #nav .menus_items { position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important; } */ /* 子菜单横向展示 */ /* #nav .menus_items .menus_item:hover .menus_item_child { display: flex !important; } */ /* 文章框大小 */ #recent-posts>.recent-post-item { height: 11em !important; } /* 搜索颜色 */ .search-dialog { background: #a5999975 !important; } /* 单行代码颜色 */ #article-container code { color: #9f0000 !important; } ::-webkit-scrollbar { width: 0px !important; } #page-header.nav-fixed #nav { z-index: 90 !important; } #page-header.nav-fixed #nav, #page-header.not-top-img #nav { box-shadow: 0 0px 0px 0px !important; background: rgb(255 255 255 / 0%) !important; } .avatar-img img { transition: filter 375ms ease-in .2s, transform 1s !important; } /* 按钮颜色 */ #pagination .page-number.current { background: #b3c8de !important; } /* 搜索到的字的颜色 */ #local-search .search-dialog .local-search__hit-item .search-keyword { color: #4fd4f1 !important; } /* 加载条 */ /* .pace { pointer-events: none; user-select: none; z-index: 2; position: fixed; margin: auto; top: 4px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 6rem; background: #eaecf2; overflow: hidden; } .pace-inactive .pace-progress { opacity: 0; transition: 0.3s ease-in; } .pace.pace-inactive { opacity: 0; transition: 0.3s; top: -8px; } .pace .pace-progress { box-sizing: border-box; transform: translate3d(0, 0, 0); position: fixed; z-index: 2; display: block; position: absolute; top: 0; right: 100%; height: 100%; width: 100%; background: #49b1f5; background: linear-gradient(to right, rgb(18, 194, 233), rgb(196, 113, 237), rgb(246, 79, 89)); animation: gradient 2s ease infinite; background-size: 200%; } */ /* 网站名的阴影 */ #nav .site-name { text-shadow: 0px 0px 0px; }"},{"title":"链接","date":"2023-01-16T07:54:47.000Z","updated":"2023-01-31T07:05:04.092Z","comments":true,"path":"link/index.html","permalink":"https://www.030215.xyz/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-08T07:23:34.389Z","updated":"2023-02-08T07:23:34.389Z","comments":true,"path":"tags/index.html","permalink":"https://www.030215.xyz/tags/index.html","excerpt":"","text":""},{"title":"链接","date":"2023-01-17T01:41:14.000Z","updated":"2023-02-05T02:13:30.201Z","comments":true,"path":"links/index.html","permalink":"https://www.030215.xyz/links/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Python/Python基础","date":"2023-02-13T02:37:53.681Z","updated":"2023-02-13T02:37:53.681Z","comments":true,"path":"article/0.html","link":"","permalink":"https://www.030215.xyz/article/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Windows下Python环境安装","slug":"Python/Python环境","date":"2023-02-12T16:00:00.000Z","updated":"2023-02-13T02:35:31.326Z","comments":true,"path":"article/88c3d0c4.html","link":"","permalink":"https://www.030215.xyz/article/88c3d0c4.html","excerpt":"","text":"下载安装包 Welcome to Python.org 勾选 Add python.exe to PATH，不勾选这个需要在系统环境变量中去配置。 选择 Customize installation 自定义安装，然后 Next 修改安装路径 最后 install 安装 完成后选择 Disable path length limit 检查安装是否成功，在 cmd 窗口输入 python，出现以下结果，即为安装完成。 vscode 配置 Python 环境 打开VScode安装 Python 插件安装完毕后重启VScode 在 VsCode 中新建文件后缀名为 .py 控制台是外部还是内部，可以通过 launch.json 文件进行调整，在左侧菜单栏，选择 运行和调试点击 创建launch.json 文件，点击 python file，将文件中的 &quot;console&quot; 的值 integratedTerminal 换成 externalTerminal","categories":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/tags/Python/"}]},{"title":"浅谈C++命名规范","slug":"习惯/编码风格","date":"2023-02-11T16:00:00.000Z","updated":"2023-02-12T12:33:30.100Z","comments":true,"path":"article/1c6fe11c.html","link":"","permalink":"https://www.030215.xyz/article/1c6fe11c.html","excerpt":"","text":"写在开头 良好的命名规范可以让程序源码更具有可读性，在程序出现 bug 时更容易找到问题所在。 对于很多人来说给函数、变量、常量命名无非是是件很痛苦的事。 一个合格的程序员给自己的程序代码命名的时候不会全部都是 a、b、c一类的，就好比一个正常的人不会给自己的孩子起名为张三、李四等。 命名要有描述性，让别人能够读懂，而不是只有自己能看懂（时间久了自己都不知道了 目前流行命名规则 小驼峰 int myAge; 大驼峰 int MyAge; 下划线 int my_age; 常见 Python 与 Linux 下 C&#x2F;C++ 开发 匈牙利 int iMyAge; 常见于 Windows 下 C&#x2F;C++ 开发，这个便于查看变量类型，但是现在的编译器做的都比较好，鼠标停留在上面就知道类型了 文件命名规范比如写的 .cpp、.h 等 这些文件尽量用小写，多个单词可以用下划线（_）或者 连字符（-）连接，不应缩写，下划线比较通用。 文件名采用 下划线命名法 类型命名规范类型包括 类 class TestCase {}; 结构体 struct TestCase {}; 类型定义 typedef std::map&lt;int, int&gt; IntMap; using 别名 using IntMap &#x3D; std::map&lt;int, int&gt;; 枚举类型 enum EnumColor {}; 类型模板参数 template&lt;class NameType, class AgeType&gt; 类型采用 大驼峰命名法 变量命名规范变量（包括函数参数）和数据成员名一律小写，单词之间可以下划线(_)连接，类的成员变量以下划线结尾，但结构体不需要以下划线结尾。 123456789101112131415int userage = 20;int user_age = 20;void CheckUserAge(int user_age) &#123; &#125;class MyClassTest &#123;private: int temp_value_; int tempvalue_;&#125;;struct LinkedList &#123; int* next_node; int* previousnode;&#125;; 类变量名采用 下划线命名法加结尾下划线 or 结尾下划线法 结构体变量名采用 下划线命名法 or 全部小写 常量命名规范被声明为 const、constexpr的变量，或者在程序运行期间始终不变的，命名时以 k 开头。 1const int kDaysInAWeek = 7; 常量采用 k + 大驼峰命名法 函数命名规范函数采用 大驼峰命名法 函数命名需要可以从函数名中知道你在这个函数里做到什么操作。 1string GetUserName() &#123;&#125; 枚举变量命名规范枚举的值都是常量，所以也应遵守常量命名规范。 k + 大驼峰 宏的方式（全是大写加下划线 123456enum RainbowColor &#123; kRed = 1, kOrange = 2, kYellow = 3, //...&#125; 命名空间命名规范 大驼峰命名法 写在最后 无论你用哪种命名方法，归根到底还是要通俗易懂，见名知意。 这些命名规则都可能会被淘汰，但是这种原则是一直都存在的。","categories":[{"name":"编程规范","slug":"编程规范","permalink":"https://www.030215.xyz/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"命名规范","slug":"命名规范","permalink":"https://www.030215.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"}]},{"title":"","slug":"Tools/vsCode相关/SettingJson","date":"2023-02-10T07:35:49.538Z","updated":"2023-02-11T09:44:45.247Z","comments":true,"path":"article/0.html","link":"","permalink":"https://www.030215.xyz/article/0.html","excerpt":"","text":"setting.json 文件（这里有 Code Runner 插件、Error Lens 插件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#123; &quot;files.associations&quot;: &#123; &quot;iostream&quot;: &quot;cpp&quot;, &quot;stdlib.h&quot;: &quot;c&quot;, &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;unordered_set&quot;: &quot;cpp&quot;, &quot;map&quot;: &quot;cpp&quot; &#125;, &quot;C_Cpp.vcFormat.newLine.beforeOpenBrace.block&quot;: &quot;sameLine&quot;, &quot;C_Cpp.vcFormat.newLine.beforeOpenBrace.function&quot;: &quot;sameLine&quot;, &quot;C_Cpp.vcFormat.newLine.beforeOpenBrace.lambda&quot;: &quot;sameLine&quot;, &quot;C_Cpp.vcFormat.newLine.beforeOpenBrace.namespace&quot;: &quot;sameLine&quot;, &quot;C_Cpp.vcFormat.newLine.beforeOpenBrace.type&quot;: &quot;sameLine&quot;, &quot;files.encoding&quot;: &quot;utf8&quot;, &quot;typescript.format.placeOpenBraceOnNewLineForFunctions&quot;: false, &quot;typescript.format.placeOpenBraceOnNewLineForControlBlocks&quot;: false, // 插件 error lens &quot;errorLens.gutterIconsEnabled&quot;: true, //在行号的左边显示小错误图标 &quot;errorLens.fontStyleItalic&quot;: true, //使错误信息的字体为斜体 // 插件 runner &quot;code-runner.runInTerminal&quot;: true, //在控制台运行代码，防止乱码和不能输入 &quot;code-runner.executorMap&quot;: &#123; &quot;javascript&quot;: &quot; cls &amp;&amp; cd /d $dir &amp;&amp; node $fullFileName &amp;&amp; pause&quot;, &quot;python&quot;: &quot; cls &amp;&amp; cd /d $dir &amp;&amp; \\&quot;$pythonPath\\&quot; -u $fullFileName &amp;&amp; pause&quot;, &quot;bat&quot;: &quot; cls &amp;&amp; cd /d $dir &amp;&amp; $fullFileName&quot;, &quot;cpp&quot;: &quot;cls &amp;&amp; cd $dir &amp;&amp; g++ -std=c++11 $fileName -o a.exe &amp;&amp; ./a.exe&quot; &#125;, &quot;code-runner.saveFileBeforeRun&quot;: true, //运行前自动保存 &quot;code-runner.customCommand&quot;: &quot; cls&quot;, //这使Ctrl+Alt+K这个快捷键可以快速清空控制台内容 &quot;code-runner.respectShebang&quot;: false, //Windows系统所以不需要按shebang来运行 &quot;code-runner.ignoreSelection&quot;: true, //禁用“运行选中部分的代码”功能&#125;","categories":[],"tags":[]},{"title":"","slug":"基础算法/5、字符串/Untitled","date":"2023-02-07T08:14:59.578Z","updated":"2023-02-07T11:01:17.222Z","comments":true,"path":"article/0.html","link":"","permalink":"https://www.030215.xyz/article/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"基础算法/4、链表/Untitled","date":"2023-02-07T08:14:57.246Z","updated":"2023-02-07T11:01:17.221Z","comments":true,"path":"article/0.html","link":"","permalink":"https://www.030215.xyz/article/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"基础算法/3、哈希表/Untitled","date":"2023-02-07T08:05:05.188Z","updated":"2023-02-09T11:42:08.904Z","comments":true,"path":"article/0.html","link":"","permalink":"https://www.030215.xyz/article/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"基础算法/2、数组/数组","date":"2023-02-07T07:54:12.015Z","updated":"2023-02-07T11:01:17.217Z","comments":true,"path":"article/0.html","link":"","permalink":"https://www.030215.xyz/article/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"1604.警告一小时内使用相同员工卡大于等于三次的人(中等)","slug":"LeetCode/1604. 警告一小时内使用相同员工卡大于等于三次的人","date":"2023-02-06T16:00:00.000Z","updated":"2023-02-07T11:01:17.211Z","comments":true,"path":"article/73006677.html","link":"","permalink":"https://www.030215.xyz/article/73006677.html","excerpt":"","text":"题目描述 1604. 警告一小时内使用相同员工卡大于等于三次的人力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。 给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。 使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 &quot;23:51&quot; 和 &quot;09:49&quot; 。 请你返回去重后的收到系统警告的员工名字，将它们按 字典序****升序 排序后返回。 请注意 &quot;10:00&quot; - &quot;11:00&quot; 视为一个小时时间范围内，而 &quot;23:51&quot; - &quot;00:10&quot; 不被视为一小时内，因为系统记录的是某一天内的使用情况。 示例 1： 123输入：keyName = [&quot;daniel&quot;,&quot;daniel&quot;,&quot;daniel&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;], keyTime = [&quot;10:00&quot;,&quot;10:40&quot;,&quot;11:00&quot;,&quot;09:00&quot;,&quot;11:00&quot;,&quot;13:00&quot;,&quot;15:00&quot;]输出：[&quot;daniel&quot;]解释：&quot;daniel&quot; 在一小时内使用了 3 次员工卡（&quot;10:00&quot;，&quot;10:40&quot;，&quot;11:00&quot;）。 示例 2： 123输入：keyName = [&quot;alice&quot;,&quot;alice&quot;,&quot;alice&quot;,&quot;bob&quot;,&quot;bob&quot;,&quot;bob&quot;,&quot;bob&quot;], keyTime = [&quot;12:01&quot;,&quot;12:00&quot;,&quot;18:00&quot;,&quot;21:00&quot;,&quot;21:20&quot;,&quot;21:30&quot;,&quot;23:00&quot;]输出：[&quot;bob&quot;]解释：&quot;bob&quot; 在一小时内使用了 3 次员工卡（&quot;21:00&quot;，&quot;21:20&quot;，&quot;21:30&quot;）。 示例 3： 12输入：keyName = [&quot;john&quot;,&quot;john&quot;,&quot;john&quot;], keyTime = [&quot;23:58&quot;,&quot;23:59&quot;,&quot;00:01&quot;]输出：[] 示例 4： 12输入：keyName = [&quot;leslie&quot;,&quot;leslie&quot;,&quot;leslie&quot;,&quot;clare&quot;,&quot;clare&quot;,&quot;clare&quot;,&quot;clare&quot;], keyTime = [&quot;13:00&quot;,&quot;13:20&quot;,&quot;14:00&quot;,&quot;18:00&quot;,&quot;18:51&quot;,&quot;19:30&quot;,&quot;19:49&quot;]输出：[&quot;clare&quot;,&quot;leslie&quot;] 提示： 1 &lt;= keyName.length, keyTime.length &lt;= 105 keyName.length == keyTime.length keyTime 格式为 “HH:MM” 。 保证 [keyName[i], keyTime[i]] 形成的二元对 互不相同 。 1 &lt;= keyName[i].length &lt;= 10 keyName[i] 只包含小写英文字母。 解题过程1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: // 转换时间 int convert(string time) &#123; int res = 0; int minues = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;); // 小时 int second = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;); // 分钟 return minues * 60 + second; &#125; // 判断 bool judge(vector&lt;int&gt;&amp; v) &#123; sort(v.begin(), v.end()); // 排序 for (int i = 2; i &lt; v.size(); ++i) &#123; // 每三个的第一个和最后一个进行比较 if (v[i] - v[i - 2] &lt;= 60) return true; &#125; return false; &#125; vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) &#123; map&lt;string, vector&lt;int&gt;&gt; map; // map 排序 vector&lt;string&gt; ret; // 返回容器 for (int i = 0; i &lt; keyName.size(); ++i) &#123; string name = keyName[i]; // 记录姓名 string time = keyTime[i]; // 记录时间 map[name].push_back(convert(time)); // 转换好的时间放到 map 容器中 &#125; for (auto&amp; KeyVal : map) &#123; if (judge(KeyVal.second)) &#123; ret.push_back(KeyVal.first); &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"使用 Obsidian 有感","slug":"Tools/使用 Obsidian 有感","date":"2023-01-31T16:00:01.000Z","updated":"2023-02-06T13:25:20.823Z","comments":true,"path":"article/1cd98177.html","link":"","permalink":"https://www.030215.xyz/article/1cd98177.html","excerpt":"","text":"前言这是使用了 Obsidian 将近一个月之后的感想。 对于这 Markdown 编辑器这方面，我觉的 Obsidian 做到十分优秀，并且其本身还是开源的，但是经过这段时间使用 ，我发现使用 Obsidian 记笔记并不适合我，尽管他在很多方面十分的优秀，但是在我手上他已经不再是一个让我写作的工具了。 Obsidian 的优势功能齐全作为一款 Markdown 编辑器，其本身该有的功能都有具备，左侧文章集合，右侧文章目录，这点比 Typora 复合式的文件和大纲要显得方便，很多快捷键可以自定义，而 Typora 修改起来相对麻烦，当然 Obsidian 也不光如此，甚至可以进行网页浏览，给界面加个时间、日历等，我觉这已经完全不是一个编辑器应做的。 插件丰富Obsidian 提供（不算提供）了大量的插件工具，其本身就是通过插件出名的，对于使用功能与工作效率方面上得到了很大的改善和提升，甚至有不少人在做相关插件的介绍与推荐。 强大的出链和回链这个功能是找到当前文章所提到的文章和提到当前文章的文章，看起来好绕，其实就是我在这面文章里写到了哪篇文章，哪篇文章里提到了我这篇文章，对于知识的链接汇总有很大帮助。 图谱其实我觉这个功能真的没啥用，但是也是一大特色吧￣へ￣ 在一个球形图谱去看关系找联系还不如刀了我(* ￣︿￣) Obsidian 的弊端无法直接打开md文件Obsidian 无法直接打开 md 文件，他就好比 vscode 一样，需要放到一个文件夹中，也就是一个库中，这就导致在打开 md 文件的时候必须创建一个文件夹的方式打开，而且里面还会有 Obsidian 原本的配置文件，我在写博客的时候这个配置文件就要让我多好几步去排除上传和以及备份。在库中打开这是他的一个致命弱点，但这也是没有办法，因为它本身有很多的依赖，提到依赖下面还有其相关的弊端。 依赖无法共享Obsidian 的依赖是放在当前存放 md 文件夹的库中的，这就导致，我在一个库中把所有设置全部完善好了，等后面再换一个库，结果就是一切重来，这里包括 自定义CSS、主题 、设置 以及 插件 等。如果想变成上一个库那样，你就需要用上一个库中的配置文件替换掉当前库的配置文件，或者重新设置… 格式上不够美观Obsidian 也是所见即所得的 Markdown 编辑器，但他并没有 Typora 的格式美观。 打个比方，Obsidian 的回车只有单行（也可以按两下(￣﹏￣；)），而 Typora 在这面却做到很好，不光是两个回车来作段落的区分，而且段内行间距也把控的很好，在文字较多的时候看着清晰明了，不至于眼花缭乱。 这个其实是可以通过 CSS 调整的，但是！我是来记笔记的不是来学 CSS 的，不是来调试的找问题的，这个过程很容易走火入魔，最后还发现很多 CSS 应用到全局的时候 编辑模式 和 阅读模式 两个模式下显示的不一样，还要分开写 CSS。 兼容性问题Obsidian 的很多功能实现，换一个软件打开效果可能就没了，这就意味着你想要看到想要的效果，就必须一直使用 Obsidian，迁移是一个很麻烦的过程。 分散精力由于 Obsidian 提供了太多的功能，导致原先的写作热情全部变成了折腾的热情了。 当然这点弊端可能是在我个人身上发生的，但不能保证没有像我一样的人，想写笔记，但又喜欢折腾的人。 写在最后这篇文章是用 Typora 写的，Obsidian 成也 插件 败也 插件。 最后我觉的 Obsidian 功能多、插件多、主题多，实则离简洁易用的 Markdown 编辑器越来越远，使用他的这个个月里，什么都可以自定义，遇到问题找插件，主题也可以自己写或者下载，折腾了很久，最后发现还是没有原先就为你准备好的 Typora 好用。想写内容没写多少，CSS 倒是精进了不少。 最后的最后，Obsidian 很漂亮、很优雅，但是！我会使用 Typora，不为别的，只为效率。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Obsidian","slug":"Obsidian","permalink":"https://www.030215.xyz/tags/Obsidian/"}]},{"title":"2325. 解密消息(简单)","slug":"LeetCode/2325. 解密消息","date":"2023-01-31T16:00:00.000Z","updated":"2023-02-01T06:59:20.724Z","comments":true,"path":"article/a7357e06.html","link":"","permalink":"https://www.030215.xyz/article/a7357e06.html","excerpt":"","text":"题目描述 2325. 解密消息给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下： 使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。 将替换表与普通英文字母表对齐，形成对照表。 按照对照表 替换 message 中的每个字母。 空格 &#39; &#39; 保持不变。 例如，key = &quot;***hap***p***y*** ***bo***y&quot;（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（&#39;h&#39; -&gt; &#39;a&#39;、&#39;a&#39; -&gt; &#39;b&#39;、&#39;p&#39; -&gt; &#39;c&#39;、&#39;y&#39; -&gt; &#39;d&#39;、&#39;b&#39; -&gt; &#39;e&#39;、&#39;o&#39; -&gt; &#39;f&#39;）。 返回解密后的消息。 示例 1： 1234输入：key = &quot;the quick brown fox jumps over the lazy dog&quot;, message = &quot;vkbs bs t suepuv&quot;输出：&quot;this is a secret&quot;解释：对照表如上图所示。提取 &quot;the quick brown fox jumps over the lazy dog&quot; 中每个字母的首次出现可以得到替换表。 示例 2： 1234输入：key = &quot;eljuxhpwnyrdgtqkviszcfmabo&quot;, message = &quot;zwx hnfx lqantp mnoeius ycgk vcnjrdb&quot;输出：&quot;the five boxing wizards jump quickly&quot;解释：对照表如上图所示。提取 &quot;eljuxhpwnyrdgtqkviszcfmabo&quot; 中每个字母的首次出现可以得到替换表。 提示： 26 &lt;= key.length &lt;= 2000 key 由小写英文字母及 &#39; &#39; 组成 key 包含英文字母表中每个字符（&#39;a&#39; 到 &#39;z&#39;）至少一次 1 &lt;= message.length &lt;= 2000 message 由小写英文字母和 &#39; &#39; 组成 解题过程12345678910111213141516171819class Solution &#123;public: string decodeMessage(string key, string message) &#123; char a = &#x27;a&#x27;; unordered_map&lt;char, char&gt; rules; for (char c : key) &#123; if (c != &#x27; &#x27; &amp;&amp; rules.count(c) == 0) &#123; rules[c] = a; ++a; &#125; &#125; for (char&amp; c : message) &#123; if (c != &#x27; &#x27;) &#123; c = rules[c]; &#125; &#125; return message; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2319. 判断矩阵是否是一个 X 矩阵(简单)","slug":"LeetCode/2319. 判断矩阵是否是一个 X 矩阵","date":"2023-01-30T16:00:00.000Z","updated":"2023-01-31T08:42:04.213Z","comments":true,"path":"article/1e8c5a8.html","link":"","permalink":"https://www.030215.xyz/article/1e8c5a8.html","excerpt":"","text":"题目描述 2319. 判断矩阵是否是一个 X 矩阵如果一个正方形矩阵满足下述 全部 条件，则称之为一个 X 矩阵 ： 矩阵对角线上的所有元素都 不是 0 矩阵中所有其他元素都是 0 给你一个大小为 n x n 的二维整数数组 grid ，表示一个正方形矩阵。如果 grid 是一个 X 矩阵 ，返回 true ；否则，返回 false 。 示例 1： 12345输入：grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]输出：true解释：矩阵如上图所示。X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。因此，grid 是一个 X 矩阵。 示例 2： 12345输入：grid = [[5,7,0],[0,3,1],[0,5,0]]输出：false解释：矩阵如上图所示。X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。因此，grid 不是一个 X 矩阵。 提示： n == grid.length == grid[i].length 3 &lt;= n &lt;= 100 0 &lt;= grid[i][j] &lt;= 105 解题过程题目比较简单，考察的点就是对角线的表达，对角线上不等于 0 ，不在对角线上等于 0 ，返回 true，否则返回 false 即可。 1234567891011121314151617class Solution &#123;public: bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int girdLength = grid.size(); for (int i = 0; i &lt; girdLength; ++i) &#123; for (int j = 0; j &lt; girdLength; ++j) &#123; if (i == j || i + j + 1 == girdLength) &#123; if (!grid[i][j]) return false; &#125; else &#123; if (grid[i][j]) return false; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1669.合并两个链表(中等)","slug":"LeetCode/1669.合并两个链表","date":"2023-01-29T16:00:00.000Z","updated":"2023-02-04T06:48:29.184Z","comments":true,"path":"article/54f169cc.html","link":"","permalink":"https://www.030215.xyz/article/54f169cc.html","excerpt":"","text":"题目描述 1669. 合并两个链表给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。 请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。 下图中蓝色边和节点展示了操作后的结果： 请你返回结果链表的头指针。 示例 1： 123输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]输出：[0,1,2,1000000,1000001,1000002,5]解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。 示例 2： 123输入：list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]输出：[0,1,1000000,1000001,1000002,1000003,1000004,6]解释：上图中蓝色的边和节点为答案链表。 提示： 3 &lt;= list1.length &lt;= 104 1 &lt;= a &lt;= b &lt; list1.length - 1 1 &lt;= list2.length &lt;= 104 解题过程普通方法123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) &#123; ListNode* nodeA = list1; for (int i = 0; i &lt; a - 1; ++i) nodeA = nodeA-&gt;next; ListNode* nodeB = nodeA-&gt;next; for (int i = 0; i &lt; b - a + 1; ++i) nodeB = nodeB-&gt;next; nodeA-&gt;next = list2; for (;list2-&gt;next != nullptr; list2 = list2-&gt;next); list2-&gt;next = nodeB; return list1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2315. 统计星号(简单)","slug":"LeetCode/2315. 统计星号","date":"2023-01-28T16:00:00.000Z","updated":"2023-02-03T09:01:38.314Z","comments":true,"path":"article/111ae7aa.html","link":"","permalink":"https://www.030215.xyz/article/111ae7aa.html","excerpt":"","text":"题目描述 2315. 统计星号给你一个字符串 s ，每 两个 连续竖线 &#39;|&#39; 为 一对 。换言之，第一个和第二个 &#39;|&#39; 为一对，第三个和第四个 &#39;|&#39; 为一对，以此类推。 请你返回 不在 竖线对之间，s 中 &#39;*&#39; 的数目。 注意，每个竖线 &#39;|&#39; 都会 恰好 属于一个对。 示例 1： 123456输入：s = &quot;l|*e*et|c**o|*de|&quot;输出：2解释：不在竖线对之间的字符加粗加斜体后，得到字符串：&quot;l|*e*et|c**o|*de|&quot; 。第一和第二条竖线 &#x27;|&#x27; 之间的字符不计入答案。同时，第三条和第四条竖线 &#x27;|&#x27; 之间的字符也不计入答案。不在竖线对之间总共有 2 个星号，所以我们返回 2 。 示例 2： 123输入：s = &quot;iamprogrammer&quot;输出：0解释：在这个例子中，s 中没有星号。所以返回 0 。 示例 3： 123输入：s = &quot;yo|uar|e**|b|e***au|tifu|l&quot;输出：5解释：需要考虑的字符加粗加斜体后：&quot;yo|uar|e**|b|e***au|tifu|l&quot; 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。 提示： 1 &lt;= s.length &lt;= 1000 s 只包含小写英文字母，竖线 &#39;|&#39; 和星号 &#39;*&#39; 。 s 包含 偶数 个竖线 &#39;|&#39; 。 解题过程1、暴力解法1234567891011class Solution &#123;public: int countAsterisks(string s) &#123; int flag, num = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &#x27;|&#x27;) ++flag; if (flag % 2 == 0 &amp;&amp; s[i] == &#x27;*&#x27;) ++num; &#125; return num; &#125;&#125;; C 指针方法12345678int countAsterisks(char * s)&#123; int num = 0,flag = 0; for (; *s != &#x27;\\0&#x27;; ++s) &#123; if (*s == &#x27;|&#x27;) ++flag; if (flag % 2 == 0 &amp;&amp; *s == &#x27;*&#x27;) ++num; &#125; return num;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2309. 兼具大小写的最好英文字母(简单)","slug":"LeetCode/2309. 兼具大小写的最好英文字母","date":"2023-01-27T16:00:00.000Z","updated":"2023-01-31T08:55:54.870Z","comments":true,"path":"article/dd4bbbc8.html","link":"","permalink":"https://www.030215.xyz/article/dd4bbbc8.html","excerpt":"","text":"题目描述 2309. 兼具大小写的最好英文字母给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。 最好 英文字母的大写和小写形式必须 都 在 s 中出现。 英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。 示例 1： 1234&gt;输入：s = &quot;lEeTcOdE&quot;&gt;输出：&quot;E&quot;&gt;解释：&gt;字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。 示例 2： 12345&gt;输入：s = &quot;arRAzFif&quot;&gt;输出：&quot;R&quot;&gt;解释：&gt;字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。&gt;注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。 示例 3： 1234&gt;输入：s = &quot;AbCdEfGhIjK&quot;&gt;输出：&quot;&quot;&gt;解释：&gt;不存在大写和小写形式都出现的字母。 提示： 1 &lt;= s.length &lt;= 1000 s 由小写和大写英文字母组成 解题过程123456789101112class Solution &#123;public: string greatestLetter(string s) &#123; unordered_set&lt;char&gt; hash(s.begin(), s.end()); for (int i = 25; i &gt;= 0; --i) &#123; if (hash.count(&#x27;a&#x27; + i) &gt; 0 &amp;&amp; hash.count(&#x27;A&#x27; + i) &gt; 0) &#123; return string(1, &#x27;A&#x27; + i); &#125; &#125; return &quot;&quot;; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"数组相关算法","slug":"基础算法/1、算法复杂度分析/2、数组相关算法","date":"2023-01-27T16:00:00.000Z","updated":"2023-02-08T07:09:31.060Z","comments":true,"path":"article/63798680.html","link":"","permalink":"https://www.030215.xyz/article/63798680.html","excerpt":"","text":"数组理论 数组是存放连续内存空间上的相同类型数据的集合 数组重点： 下标从 0 开始（部分语言不是从 0 开始 数组内存空间地址是连续的 删除和添加元素，需要移动其他元素的地址（数组元素是不能删除的，只能覆盖 二维数组，在空间上的地址也是连续的 测试代码 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int arr[2][3] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;; for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); ++i) &#123; for (int j = 0; j &lt; sizeof(arr[0]) / sizeof(arr[0][0]); ++j) &#123; cout &lt;&lt; &amp;arr[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; getchar(); return 0;&#125; 运行结果 0x61fe00 0x61fe04 0x61fe08 0x61fe0c 0x61fe10 0x61fe14 每个地址相差 4 个字节，因为这是 int 类型，16 进制中 c 代表 十进制中 的 12 所以在C++中二维数组在地址上是连续的 二分查找 704. 二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题过程二分查找的使用条件 首先这个序列必须是有序的 这个序列无重复的元素（重复元素会导致返回下标不统一 二分一学就会，一写就废 12345678910111213class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; else return mid; &#125; return -1; &#125;&#125;; 二分涉及到很多边界条件 while(left &lt; right) 是 &lt;= 还是","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://www.030215.xyz/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法基础","slug":"算法基础","permalink":"https://www.030215.xyz/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"876. 链表的中间结点(简单)","slug":"LeetCode新手村/876. 链表的中间结点","date":"2023-01-26T16:00:00.000Z","updated":"2023-01-31T08:55:47.739Z","comments":true,"path":"article/23908.html","link":"","permalink":"https://www.030215.xyz/article/23908.html","excerpt":"","text":"题目描述 876. 链表的中间结点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 解题过程方法 112345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* currentNode = head; int listLength = 0; for (; currentNode != nullptr; currentNode = currentNode-&gt;next)&#123; ++listLength; &#125; currentNode = head; for (int i = 0; i &lt; listLength / 2; i++)&#123; currentNode = currentNode-&gt;next; &#125; return currentNode; &#125;&#125;; 方法 2快慢指针 使用双指针，指针1每次移动两个指针大小，指针2每次移动一个指针大小，指针1到 nullptr之后 指针2就在中间的位置 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* fastPtr = head; ListNode* slowPtr = head; while (fastPtr != nullptr &amp;&amp; fastPtr-&gt;next != nullptr)&#123; fastPtr = fastPtr-&gt;next-&gt;next; slowPtr = slowPtr-&gt;next; &#125; return slowPtr; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"复杂度分析","slug":"基础算法/1、算法复杂度分析/1、复杂度分析","date":"2023-01-26T16:00:00.000Z","updated":"2023-02-10T07:35:14.395Z","comments":true,"path":"article/54635.html","link":"","permalink":"https://www.030215.xyz/article/54635.html","excerpt":"","text":"时间复杂度分析 算法超时 递归算法的时间复杂度 算法性能分析 空间复杂度分析 递归算法的性能分析 内存消耗 时间复杂度分析大 O 表示 大 O 表示上届的，用它作为算法的最坏情况 输入数据对程序运行速度有很大的影响，假设使用 快速排序 ，如果输入的数据顺序是随机的，时间复杂度是 O(nlogn) ，但是当数据已经是有序的情况下，则时间复杂度是 O(n^2)。以 大O 的定义来讲，快速排序的时间复杂度是 o(n^2)，但是我们却说 快排 的时间复杂度是 O(nlogn)，这里的 O 代表一般情况。 其实还是比较在意 一般情况 下的数据形式 数据用例不同，时间复杂度也是不同的 数据规模在决定使用算法的时候，并不是 时间复杂度 越低越好，因为时间复杂度忽略了表达式的一部分。 所以需要考虑问题的规模，在有常数项的时候且问题规模较小，使用 O(n^2) 的算法比使用 O(n) 要好 大 O 是数据突破一个点且数据量非常大的情况下所表现出来的时间复杂度，这个非常大是指常数项系数已经不起决定性作用。也就是为什么用 O(n) 时间复杂度代替 O(xn) (x为常系数)，用 O(n^2) 时间复杂度代替 O(xn^2) (x为常系数)。 所以常说的时间复杂度是省略常数项系数的，在默认数据规模足够大的时候满足以下复杂度排序 O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3) &lt; O(2^n)指数阶 大 O 化简一般提到的算法时间复杂度 O(n)、O(n^2)等，其实这些是通过简化后得来的 例如： 1O(2*n^2 + 10*n + 10000) 去掉常数项，常数项不会随着 n 的增大而增大 1O(2*n^2 + 10*n) 去掉常数系数，常数系数起不到决定性作用 1O(n^2 + 10*n) 去掉常数系数 1O(n^2 + n) 只保留最高项，去掉数量级小一级的 n，其实也可以这个理解：O(n(n+1))，去掉常数项 1O(n^2) 最后的到这个算法的复杂度为 O(n^2) log的底数以 2 为底 n 的对数 &#x3D; 以 2 为底 10 的对数 + 以 10 为底 n 的对数 根据上面 大O 的化简，以 2 为底 10 的对数 是一个常数，所以就进行简化，再次抽象上面的等式，以 2 为底 n 的对数 &#x3D; 以 10 为底 n 的对数 ，所以这里的 2 和 10 已经不重要了，直接就是 logn。 算法超时","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://www.030215.xyz/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法基础","slug":"算法基础","permalink":"https://www.030215.xyz/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}]},{"title":"1664. 生成平衡数组的方案数(中等)","slug":"LeetCode/1664. 生成平衡数组的方案数","date":"2023-01-25T16:00:00.000Z","updated":"2023-02-06T13:27:04.154Z","comments":true,"path":"article/24712d21.html","link":"","permalink":"https://www.030215.xyz/article/24712d21.html","excerpt":"","text":"题目描述 1664. 生成平衡数组的方案数给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。 比方说，如果 nums = [6,1,7,4,1] ，那么： 选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。 选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。 选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。 如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。 请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。 示例 1： 12345678输入：nums = [2,1,6,4]输出：1解释：删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。只有一种让剩余数组成为平衡数组的方案。 示例 2： 123输入：nums = [1,1,1]输出：3解释：你可以删除任意元素，剩余数组都是平衡数组。 示例 3： 123输入：nums = [1,2,3]输出：0解释：不管删除哪个元素，剩下数组都不是平衡数组。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 解题过程1、暴力解法123456789101112131415161718class Solution &#123;public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) &#123; int num = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; vector&lt;int&gt; v = nums; v.erase(v.begin() + i); int length = v.size(); int sum1 =0, sum2 = 0; for (int j = 0; j &lt; length; ++j) &#123; if (j % 2 == 0) sum1 += v[j]; else sum2 += v[j]; &#125; if (sum1 == sum2) ++num; &#125; return num; &#125;&#125;; hhh 直接超时了 2、动态规划","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1480. 一维数组的动态和(简单)","slug":"LeetCode新手村/1480. 一维数组的动态和","date":"2023-01-24T16:00:00.000Z","updated":"2023-01-28T11:14:55.243Z","comments":true,"path":"article/45719.html","link":"","permalink":"https://www.030215.xyz/article/45719.html","excerpt":"","text":"新年第一道题，找个简单的(¬_¬ ) 题目描述 1480. 一维数组的动态和给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 123&gt;输入：nums = [1,2,3,4]&gt;输出：[1,3,6,10]&gt;解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 123&gt;输入：nums = [1,1,1,1,1]&gt;输出：[1,2,3,4,5]&gt;解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 12&gt;输入：nums = [3,1,2,10,1]&gt;输出：[3,4,6,16,17] 提示： 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 解题过程方法 1所求数组的每一位是所给数组的这个位置前面的数字（包括当前位置）累加的和 新建一个数组，用一个整形去存放累加和，放到新数组，这样数据多的时候比较耗内存，但是只用遍历一次，空间换时间 12345678910111213class Solution &#123;public: vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), sum = 0; vector&lt;int&gt; v(n); // 初始化 n 个空间 sum = v[0] = nums[0]; // 第一个数是不变的 for (int i = 1; i &lt; n; i++) &#123; sum += nums[i]; // 累加 v[i] = sum; &#125; return v; &#125;&#125;; 方法 2上面的方法在如果给定数组长度很长，这样的做法是很费空间的，其实也可以写成单个数组的形式，直接在已给数组上进行操作 index(1) &#x3D; index(1) + index(0) index(2) &#x3D; index(2) + index(1) index(3) &#x3D; index(3) + index(2) 有点递归的感觉 12345678class Solution &#123;public: vector&lt;int&gt; runningSum1(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); i++) nums[i] += nums[i - 1]; // 相加的结果之后进行累加 return nums; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"26. 删除有序数组中的重复项(简单)","slug":"LeetCode新手村/26.删除有序数组中的重复项","date":"2023-01-24T16:00:00.000Z","updated":"2023-01-28T11:12:52.127Z","comments":true,"path":"article/4154.html","link":"","permalink":"https://www.030215.xyz/article/4154.html","excerpt":"","text":"题目描述 26. 删除有序数组中的重复项给你一个 升序排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 升序 排列 解题过程1、暴力解法题目要求在原数组上进行修改，不能使用新空间去存储 下面是第一次写代码 123456789class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); ++i) if (nums[i] == nums[i - 1]) nums.erase(nums.begin()+i); return nums.size(); &#125;&#125;; 调用的类方法去做，然而案例2都没过去 案例2：[0,0,1,1,1,2,2,3,3,4] 结果：[0,1,1,2,3,4] 不知道为什么多出来了个 1，忽略调用 erase 删除元素之后，后面元素的下标也会跟着改变 当一个数重复出现奇数次的时候，就会保留两个 所以这里需要对 nums[i] == nums[i - 1] 再次判断 下面修改后的代码 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return nums.size(); // 一个数就没必要继续 for (int i = 1; i &lt; nums.size(); ++i) if (nums[i] == nums[i - 1]) &#123; nums.erase(nums.begin()+i); --i; // 删除元素后对 i 进行减 1 &#125; return nums.size(); &#125;&#125;; 耗时击败 5% (╯°□°）╯︵ ┻━┻) 没太注意题目，题目说不需要考虑数组中超出新长度后面的元素。 所以这里还可以优化，不用删除重复的元素 12345678910111213class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return nums.size(); int index = 0; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[index] != nums[i])&#123; nums[++index] = nums[i]; &#125; &#125; return ++index; &#125;&#125;; 2、双指针双指针方法 12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return nums.size(); int p = 0; int q = 1; while (q &lt; nums.size()) &#123; if (nums[p] != nums[q]) &#123; nums[p + 1] = nums[q]; ++p; &#125; ++q; &#125; return p + 1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1342. 将数字变成 0 的操作次数(简单)","slug":"LeetCode新手村/1342. 将数字变成 0 的操作次数","date":"2023-01-23T16:00:00.000Z","updated":"2023-01-28T11:12:14.991Z","comments":true,"path":"article/17862.html","link":"","permalink":"https://www.030215.xyz/article/17862.html","excerpt":"","text":"题目描述 1342. 将数字变成 0 的操作次数给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。 示例 1： 123456789输入：num = 14输出：6解释：步骤 1) 14 是偶数，除以 2 得到 7 。步骤 2） 7 是奇数，减 1 得到 6 。步骤 3） 6 是偶数，除以 2 得到 3 。步骤 4） 3 是奇数，减 1 得到 2 。步骤 5） 2 是偶数，除以 2 得到 1 。步骤 6） 1 是奇数，减 1 得到 0 。 示例 2： 1234567输入：num = 8输出：4解释：步骤 1） 8 是偶数，除以 2 得到 4 。步骤 2） 4 是偶数，除以 2 得到 2 。步骤 3） 2 是偶数，除以 2 得到 1 。步骤 4） 1 是奇数，减 1 得到 0 。 示例 3： 12输入：num = 123输出：12 提示： 0 &lt;= num &lt;= 10^6 解题过程方法 1使用递归方法，不知道为什么明明 执行代码 的输出结果是对的，提交之后输出结果就是错的 错误原因是因为使用了一个不该使用的 static ，使用静态变量，力扣大概会对这个类的方法重复使用比如说 所以这里不能使用 static关键字 123456789101112131415class Solution &#123;public: int numberOfSteps(int num) &#123; if (num == 0) return sum; if (num % 2 == 0) &#123; num /= 2;++sum; return numberOfSteps(num); &#125; else &#123; num -= 1;++sum; return numberOfSteps(num); &#125; &#125; int sum = 0;&#125;; 方法 2对于有 除 2 相关的操作，我们可以使用 位运算 来加快执行用时，用 while 来做判断依据 123456789101112class Solution &#123;public: int numberOfSteps(int num) &#123; int count = 0; while (num)&#123; if (num % 2 == 0) num &gt;&gt;= 1; else --num; ++count; &#125; return count; &#125;&#125;; 对于一些简单问题，可以先进行解题，然后再在其基础上进行优化如二维优化一维、是否可以在已给数据上进行操作、是否可以用逆向、是否可以用递归或者位运算等等","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"383. 赎金信(简单)","slug":"LeetCode新手村/383. 赎金信","date":"2023-01-23T16:00:00.000Z","updated":"2023-01-28T11:12:54.218Z","comments":true,"path":"article/51782.html","link":"","permalink":"https://www.030215.xyz/article/51782.html","excerpt":"","text":"题目描述 383. 赎金信给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 解题过程先对后面的字符串进行挨个计数，把每一个出现的字母所对应的位置进行递增操作 再对第一个字符串进行遍历，出现一个字符就对数组中的这个计数进行递减操作 当出现数组中的计数出现负数的时候，就说明第一个字符串包含的单个字母的个数较多，第二个字符串内的字符无法组成第一个字符串 12345678910111213class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.size() &gt; magazine.size()) return false; vector&lt;int&gt; v(26); for (auto&amp; c : magazine) v[c - &#x27;a&#x27;]++; for (auto&amp; c : ransomNote) &#123; v[c - &#x27;a&#x27;]--; if (v[c - &#x27;a&#x27;] &lt; 0) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"412. Fizz Buzz(简单)","slug":"LeetCode新手村/412. Fizz Buzz","date":"2023-01-22T16:00:00.000Z","updated":"2023-01-28T11:12:56.370Z","comments":true,"path":"article/5048.html","link":"","permalink":"https://www.030215.xyz/article/5048.html","excerpt":"","text":"题目描述 412. Fizz Buzz给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == &quot;FizzBuzz&quot; 如果 i 同时是 3 和 5 的倍数。 answer[i] == &quot;Fizz&quot; 如果 i 是 3 的倍数。 answer[i] == &quot;Buzz&quot; 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。 示例 1： 12输入：n = 3输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;] 示例 2： 12输入：n = 5输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;] 示例 3： 12输入：n = 15输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;] 提示： 1 &lt;= n &lt;= 104 解题过程12345678910111213class Solution &#123;public: vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; v; for (int i = 1; i &lt;= n; ++i) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) v.push_back(&quot;FizzBuzz&quot;); else if (i % 3 == 0) v.push_back(&quot;Fizz&quot;); else if (i % 5 == 0) v.push_back(&quot;Buzz&quot;); else v.push_back(to_string(i)); &#125; return v; &#125;&#125;; c语言写出来有点麻烦，注意二维数组需要进行指定空间和用 sprintf 函数向数组写入整形字符 12345678910111213char ** fizzBuzz(int n, int* returnSize)&#123; char** answer = (char**)malloc(sizeof(char*)*n); char* str = (char*)malloc(sizeof(char)*9*n); // 最长 9n for (int i = 0; i &lt; n; ++i) answer[i] = &amp;str[9*i]; // 指定空间 for (int i = 1; i &lt;= n; ++i) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) strcpy(answer[i -1], &quot;FizzBuzz&quot;); else if (i % 3 == 0) strcpy(answer[i - 1], &quot;Fizz&quot;); else if (i % 5 == 0) strcpy(answer[i - 1], &quot;Buzz&quot;); else sprintf(answer[i - 1], &quot;%d&quot;, i); &#125; *returnSize = n; return answer;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2303. 计算应缴税款总额(简单)","slug":"LeetCode/2303. 计算应缴税款总额","date":"2023-01-21T16:00:00.000Z","updated":"2023-01-28T11:11:24.565Z","comments":true,"path":"article/50305.html","link":"","permalink":"https://www.030215.xyz/article/50305.html","excerpt":"","text":"题目描述 2303. 计算应缴税款总额给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 &lt; i &lt; brackets.length 的前提下，upperi-1 &lt; upperi）。 税款计算方式如下： 不超过 upper0 的收入按税率 percent0 缴纳 接着 upper1 - upper0 的部分按税率 percent1 缴纳 然后 upper2 - upper1 的部分按税率 percent2 缴纳 以此类推 给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。 示例 1： 1234567输入：brackets = [[3,50],[7,10],[12,25]], income = 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。 示例 2： 123456输入：brackets = [[1,0],[4,25],[5,50]], income = 2输出：0.25000解释：前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。需要支付的税款总计 $0 + $0.25 = $0.25 。 示例 3： 1234输入：brackets = [[2,50]], income = 0输出：0.00000解释：没有收入，无需纳税，需要支付的税款总计 $0 。 提示： 1 &lt;= brackets.length &lt;= 100 1 &lt;= upperi &lt;= 1000 0 &lt;= percenti &lt;= 100 0 &lt;= income &lt;= 1000 upperi 按递增顺序排列 upperi 中的所有值 互不相同 最后一个税级的上限大于等于 income 解题过程方法 1不知道这个 income 到底位于这个二维数组的那个区间，所以可以使用比较笨的方法(～￣(OO)￣)ブ（二分好像也可以），直接遍历，每遍历完一遍记录以下当前值的前面一个 税级 ，当遇到income不大于税级的时候执行收入 - 税级 * 税率，退出循环，否则就是（当前税级 - 上一个税级） * 当前税率，并更新最后一个比收益小的税级 12345678910111213141516171819class Solution &#123;public: double calculateTax(vector&lt;vector&lt;int&gt;&gt;&amp; brackets, int income) &#123; double tax = 0; int x = 0; // 最后一个比收益小的税级 int n = brackets.size(); for (int i = 0; i &lt; n; i++) &#123; if (income &lt;= brackets[i][0]) &#123; tax += (income - x) * brackets[i][1]; break; &#125; else &#123; tax += (brackets[i][0] - x) * brackets[i][1]; x = brackets[i][0]; // 更新前一个税级 &#125; &#125; return tax / 100.0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2299. 强密码检验器 II(简单)","slug":"LeetCode/2299. 强密码检验器 II","date":"2023-01-20T16:00:00.000Z","updated":"2023-01-28T11:11:14.444Z","comments":true,"path":"article/20129.html","link":"","permalink":"https://www.030215.xyz/article/20129.html","excerpt":"","text":"题目描述 2299. 强密码检验器 II如果一个密码满足以下所有条件，我们称它是一个 强 密码： 它有至少 8 个字符。 至少包含 一个小写英文 字母。 至少包含 一个大写英文 字母。 至少包含 一个数字 。 至少包含 一个特殊字符 。特殊字符为：&quot;!@#$%^&amp;*()-+&quot; 中的一个。 它 不 包含 2 个连续相同的字符（比方说 &quot;aab&quot; 不符合该条件，但是 &quot;aba&quot; 符合该条件）。 给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。 示例 1： 123&gt;输入：password = &quot;IloveLe3tcode!&quot;&gt;输出：true&gt;解释：密码满足所有的要求，所以我们返回 true 。 示例 2： 123&gt;输入：password = &quot;Me+You--IsMyDream&quot;&gt;输出：false&gt;解释：密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。 示例 3： 123&gt;输入：password = &quot;1aB!&quot;&gt;输出：false&gt;解释：密码不符合长度要求。所以我们返回 false 。 提示： 1 &lt;= password.length &lt;= 100 password 包含字母，数字和 &quot;!@#$%^&amp;*()-+&quot; 这些特殊字符。 解题过程题目较为简单，题目中的密码要求也很有意思，特殊字符正好是键盘上数字那一排，由于对 ASCII 码不太熟悉，我以为会有什么规律，结果规律并不明显 123456789101112! 33@ 64# 35$ 36% 37^ 94&amp; 38* 42( 40) 41- 45+ 43 于是就干脆使用 switch 进行选择了 以下是我第一次做的时候的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class solution &#123;public: bool strongPasswordCheckerII(string password) &#123; int len = password.length(); if (len &lt; 8) return false; // 至少包含一个，反面一个都没有 short daxie = 0; short xiaoxie = 0; short shuzi = 0; short teshu = 0; int length = len; for (int i = 0; i &lt; length; i++) &#123; if (i != 0 &amp;&amp; password[i] == password[i - 1]) return false; if (password[i] &gt;= &#x27;A&#x27; &amp;&amp; password[i] &lt;= &#x27;Z&#x27;) &#123; daxie++; continue; &#125; if (password[i] &gt;= &#x27;a&#x27; &amp;&amp; password[i] &lt;= &#x27;z&#x27;) &#123; xiaoxie++; continue; &#125; if (password[i] &gt;= &#x27;0&#x27; &amp;&amp; password[i] &lt;= &#x27;9&#x27;) &#123; shuzi++; continue; &#125; switch (password[i]) &#123; case &#x27;!&#x27;: teshu++; continue; case &#x27;@&#x27;: teshu++; continue; case &#x27;#&#x27;: teshu++; continue; case &#x27;$&#x27;: teshu++; continue; case &#x27;%&#x27;: teshu++; continue; case &#x27;^&#x27;: teshu++; continue; case &#x27;&amp;&#x27;: teshu++; continue; case &#x27;*&#x27;: teshu++; continue; case &#x27;(&#x27;: teshu++; continue; case &#x27;)&#x27;: teshu++; continue; case &#x27;-&#x27;: teshu++; continue; case &#x27;+&#x27;: teshu++; continue; &#125; &#125; if (daxie != 0 &amp;&amp; xiaoxie != 0 &amp;&amp; teshu != 0 &amp;&amp; shuzi != 0) return true; else return false; &#125;&#125;; 不得不说写的很繁琐，但运行是过了，不知道为什么耗时 0ms ，应该是卡了吧(ToT)&#x2F;~~~","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"Typora 快捷键","slug":"Tools/Typora快捷键","date":"2023-01-20T16:00:00.000Z","updated":"2023-01-28T11:10:13.813Z","comments":true,"path":"article/41636.html","link":"","permalink":"https://www.030215.xyz/article/41636.html","excerpt":"","text":"记载常用的即可（又不常用的(～￣▽￣)～ 文件 新建：ctrl+N 新建窗口：ctrl+shift+N 打开：ctrl+O（以文件的形式） 快速打开：ctrl+P（当前目录下的所有 .md 文件快速打开） 另存为：ctrl+shift+S 关闭：ctrl+W 编辑 标题：ctrl+1/2/3/4/5/6 表格：ctrl+T 代码块：ctrl+shift+K 代码：ctrl+shift+ &#96; 公式快：ctrl+shift+M 引用：ctrl+shift+Q 有序列表：ctrl+shift+[(还是 - 更方便 有序列表：ctrl+shift+] 增加缩进：ctrl+] 减少缩进：ctrl+[ 加粗：ctrl+B 斜体：ctrl+I 下划线：ctrl+U 超链接：ctrl+K 图像：ctrl+shift+I 视图 侧边栏隐藏：ctrl+shift+L 大纲视图：ctrl+shift+1 文档列表视图：ctrl+shift+2 文件树视图：ctrl+shift+3 源代码模式：ctrl+/ 专注模式：F8 打字机模式：F9 切换全屏：F11 实际大小：ctrl+shift+0 放大：ctrl+shift+= 缩小：ctrl+shift+- 应用内打开窗口：ctrl+Tab 打开DevTools：shift+F12 外加一点外 1234561. 带 &#123;% u 下划线 %&#125; 的文本2. 带 &#123;% emp 着重号 %&#125; 的文本3. 带 &#123;% wavy 波浪线 %&#125; 的文本4. 带 &#123;% del 删除线 %&#125; 的文本5. 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;6. 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://www.030215.xyz/tags/Typora/"}]},{"title":"1828. 统计一个圆中点的数目(中等)","slug":"LeetCode/1828. 统计一个圆中点的数目","date":"2023-01-19T16:00:00.000Z","updated":"2023-01-28T11:11:06.174Z","comments":true,"path":"article/62886.html","link":"","permalink":"https://www.030215.xyz/article/62886.html","excerpt":"","text":"题目描述 1828. 统计一个圆中点的数目给你一个数组 points ，其中 points[i] = [xi, yi] ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。 同时给你一个数组 queries ，其中 queries[j] = [xj, yj, rj] ，表示一个圆心在 (xj, yj) 且半径为 rj 的圆。 对于每一个查询 queries[j] ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。 请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。 示例 1： 1234输入：points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]输出：[3,2,2]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。 示例 2： 1234输入：points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]输出：[2,3,2,4]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。 提示： 1 &lt;= points.length &lt;= 500 points[i].length == 2 0 &lt;= xi, yi &lt;= 500 1 &lt;= queries.length &lt;= 500 queries[j].length == 3 0 &lt;= xj, yj &lt;= 500 1 &lt;= rj &lt;= 500 所有的坐标都是整数。 解题过程点在圆内的公式 (x1 - x2)^2 - (y1 - y2)^2 &lt; r^2 ，注意题目说在圆上也算 循环圆的个数，在当前圆内对每一个点进行判断即可 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; // 判定一个圆内有几个点（包括圆上），points代表点（x1，y1），queries代表圆（x2，y2，半径） // 创建一个数组容器 vector&lt;int&gt; retV; // 创建一个圆的数量的大小的容器 // (x1 - x2)^2 + (y1 - y2)^2 &lt; r^2 点在圆内公式 for (auto&amp; querie : queries) &#123; int num = 0; // 在圆内的个数 for (auto&amp; point : points) &#123; if (pow(point[0] - querie[0], 2) + pow(point[1] - querie[1], 2) &lt;= pow(querie[2], 2)) &#123; ++num; &#125; &#125; retV.push_back(num); &#125; return retV; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"git 端口22失败问题","slug":"Tools/git端口错误","date":"2023-01-19T16:00:00.000Z","updated":"2023-01-28T11:10:06.233Z","comments":true,"path":"article/24454.html","link":"","permalink":"https://www.030215.xyz/article/24454.html","excerpt":"","text":"解决报错问题方法1 打开 windows 防火墙，高级设置 新建入站规则 选择端口 新建特定端口，写入 22 之后保存 方法2使用的网络有问题，使用别的网络试一下 这个问题困扰了我很长时间，每次再用 git 进行提交的时候总是显示没有权限，和端口请求失败，以至于想放弃使用 ssh，其实也可以使用 https 的方式去推送和拉取代码","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.030215.xyz/tags/git/"}]},{"title":"1824. 最少侧跳次数(中等)","slug":"LeetCode/1824.最少侧跳数","date":"2023-01-18T16:00:00.000Z","updated":"2023-01-28T11:10:56.620Z","comments":true,"path":"article/35387.html","link":"","permalink":"https://www.030215.xyz/article/35387.html","excerpt":"","text":"题目描述 1824. 最少侧跳次数给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。 给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。 比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。 这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。 这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。 注意：点 0 处和点 n 处的任一跑道都不会有障碍。 示例 1： 1234&gt;输入：obstacles = [0,1,2,3,0]&gt;输出：2 &gt;解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。&gt;注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。 示例 2： 123&gt;输入：obstacles = [0,1,1,3,3,0]&gt;输出：0&gt;解释：跑道 2 没有任何障碍，所以不需要任何侧跳。 示例 3： 123&gt;输入：obstacles = [0,2,1,0,3,0]&gt;输出：2&gt;解释：最优方案如上图所示。总共有 2 次侧跳。 提示： obstacles.length == n + 1 1 &lt;= n &lt;= 5 * 105 0 &lt;= obstacles[i] &lt;= 3 obstacles[0] == obstacles[n] == 0 解题过程1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) &#123; // 记录数组长度 int n = obstacles.size(); int INF = 0x3f3f3f3f; // 方便寻找没有障碍的跑道 int way[3][2] = &#123; &#123;1, 2&#125;, &#123;0, 2&#125; , &#123;0, 1&#125; &#125;; // 当前路线到零一路线最少次数 int f[3]; f[0] = 1; f[1] = 0; f[2] = 1; // 默认在中间一排 // one、two 表示没有阻碍的两条跑道 // w 表示有障碍的道路 int one = 0, two = 1, w = 2; // 随意初始化 // 从 1 开始遍历 obstacles for (int i = 1; i &lt; n; i++) &#123; // 没有障碍 if (obstacles[i] == 0) &#123; // 使用上一次的数据更新之前有障碍的跑道 f[w] = min(f[one], f[two]) + 1; continue; &#125; w = obstacles[i] - 1; f[w] = INF; one = way[w][0]; two = way[w][1]; f[one] = min(f[one], f[two] + 1); f[two] = min(f[one] + 1, f[two]); &#125; return min(min(f[0], f[1]), f[2]); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"vika + PicGo 图床搭建","slug":"Tools/图床搭建","date":"2023-01-18T16:00:00.000Z","updated":"2023-02-04T06:06:43.121Z","comments":true,"path":"article/38401.html","link":"","permalink":"https://www.030215.xyz/article/38401.html","excerpt":"","text":"前言 原先使用 GitHub + PicGo 的方式搭建图床，显示效果不好，一张几百kb的照片需要加载四五秒，由于开了图片懒加载所以没显示图片的这个期间，图片哪里就是空白的，所以直接弃用 GitHub 搭建图床的方式，选用有国内服务器的 vika，使用起来也比 GitHub 稍微简单一点，最主要的是对于代理是没有要求的，原先使用 GitHub 作图床时，需要关闭代理，否则上传只会失败，而我使用git又需要代理，开来开去好麻烦(￣﹏￣；) 注册 vika vika 链接：https://vika.cn/?inviteCode=55298644 注册进入后，点击左侧控制台，进入工作目录，点击加号新建空白维格表 点击左下角头像选择个人设置，进入开发者配置 第一次进去是一个加号，点击加号，会进行绑定邮箱操作，绑定之后，回到刚刚新建表格找到 API 进入 API 选项，点击Get 获取，复制下面datasheets后面两个/之间的一串字母，这个是 维格表ID，再复制Bearer后面的一串字符，这个是token，后期也可以在开发者配置中去复制 PicGo 下载 PicGo (github.com) PicGo 需要插件才支持 vika，到插件设置去下载 记得在PicGo设置中打开vika 在图床设置中打开vika维格表 API Token 填写上面复制的 token 即可 维格表ID填写上面复制的datasheets后面的内容 其余内容可以默认，最后别忘了点击确定 此时就可以在上传区上传图片 PicGo 搭配 Typora 使用Typora 网盘链接： 链接：https://pan.baidu.com/s/1gVErYFgH7OROigXSAy_CPw?pwd=n4bc提取码：n4bc解压码：3215 在 Typora 软件中找到文件进入偏好设置点击图像 插入图片选择上传图片下面的勾选 上传服务选择PicGo(app)，下面填写他的安装路径即可 这个时候就可以在 Typora 中粘贴图片的时候，图片自己上传到vika并生成 URL 链接 压缩图片图片的大小会影响其加载速度，所以在保证图片质量的前提下，尽可能的减小图片内存大小 使用工具 Caesium - Image Compressor (软件) TinyPNG – Compress(网站)","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://www.030215.xyz/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"博客备份和迁移","slug":"Blog/博客备份和迁移","date":"2023-01-17T16:00:00.000Z","updated":"2023-02-06T13:28:47.629Z","comments":true,"path":"article/53348.html","link":"","permalink":"https://www.030215.xyz/article/53348.html","excerpt":"","text":"备份新建 GitHub 仓库，将本地网站文件通过 git 与 GitHub 相连接 在本地文件中右键打开 Git Bash Here 1git init 1git remote add origin git@github.com:用户名/仓库.git 在网站文件根目录下新建一个shell脚本，命名为 push.sh 复制一下内容进入脚本 1234567891011echo -e &quot;\\033[32m正在为你备份博客中.........\\033[0m&quot;git add .echo -e &quot;\\033[32m正在为你备份博客中.........\\033[0m&quot;git commit -m &quot;update&quot;echo -e &quot;\\033[32m正在为你备份博客中.........\\033[0m&quot;git push origin master --forceif [ $? -ne 0 ]; then echo -e &quot;\\033[31m 备份失败！请检查网络情况！ \\033[0m&quot;else echo -e &quot;\\033[32m恭喜你！已为你备份到你的GitHub仓库 backup \\033[0m&quot;fi 在网站文件右键打开 Git Bash Here 输入 ./push.sh 即可完成备份 两键上传加备份在桌面写一个 dp.sh.dat 名字随意，后缀 .bat ，文件写入以下内容 1cmd /k &quot;cd /d D:\\distake\\blog&amp;&amp;hexo cl&amp;&amp;hexo g&amp;&amp;gulp&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin master --force&quot; &#x2F;k 表示执行结束后不退出控制台，可以化成 &#x2F;cgulp 使用的前提是要有 gulp 包，并且添加一个 js 脚本，用于压缩文件 安装 gulp 12npm install gulp -gnpm install gulp-minify-html gulp-minify-css gulp-uglify gulp-imagemin --save 根目录下建立 gulpfile.js 文件，写入以下内容 12345678910111213141516171819202122232425262728293031323334353637383940var gulp = require(&#x27;gulp&#x27;);//Plugins模块获取var minifycss = require(&#x27;gulp-minify-css&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;);var htmlmin = require(&#x27;gulp-htmlmin&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);//压缩cssgulp.task(&#x27;minify-css&#x27;, function () &#123; return gulp.src(&#x27;./public/**/*.css&#x27;) .pipe(minifycss()) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//压缩htmlgulp.task(&#x27;minify-html&#x27;, function () &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩js 不压缩min.jsgulp.task(&#x27;minify-js&#x27;, function () &#123; return gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(uglify()) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//4.0以前的写法 //gulp.task(&#x27;default&#x27;, [// &#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task(&#x27;default&#x27;, gulp.parallel(&#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, function (done) &#123; // Do something after a, b, and c are finished. done();&#125;)); 迁移第一步：安装 Hexo 环境 &#x2F; 工具 nodejs：Node.js (nodejs.org) git：Git - Downloads (git-scm.com) or 提供git(windows)下载 - 网达极客社区 (gitclone.com) 第二步：配置密钥信息在本地文件夹中输入以下指令，会生成密钥，需要到 GitHub 设置中去添加密钥（公钥 123ssh-keygen -t rsa -C &quot;邮箱&quot;git config --global user.name &quot;英文名字&quot;git config --global user.email &quot;邮箱&quot; 生成公钥的位置，在本地中 第三步：克隆仓库1git clone git@github.com:用户名/仓库.git 对 npm 进行安装 1npm install 至此，迁移完成 写在最后博客是一种记录的方式，最后希望这种方式依然长久","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"1817. 查找用户活跃分钟数(中等)","slug":"LeetCode/1817. 查找用户活跃分钟数","date":"2023-01-17T16:00:00.000Z","updated":"2023-02-03T09:12:10.100Z","comments":true,"path":"article/54870.html","link":"","permalink":"https://www.030215.xyz/article/54870.html","excerpt":"","text":"题目描述 1817. 查找用户活跃分钟数给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDi, timei] 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。 多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。 指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。 请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 &lt;= j &lt;= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。 返回上面描述的答案数组 answer 。 示例 1： 123456&gt;输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5&gt;输出：[0,2,0,0,0]&gt;解释：&gt;ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）&gt;ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2&gt;2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 示例 2： 1234567&gt;输入：logs = [[1,1],[2,2],[2,3]], k = 4&gt;输出：[1,1,0,0]&gt;解释：&gt;ID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1&gt;ID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2&gt;1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 &gt;因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0 提示： 1 &lt;= logs.length &lt;= 104 0 &lt;= IDi &lt;= 109 1 &lt;= timei &lt;= 105 k 的取值范围是 [用户的最大用户活跃分钟数, 105] 解题过程这个题刚开始读的时候有点懵(这个难道不是语文阅读吗ಠಿ_ಠ) 先从输出结果来看示例1中[0, 2, 0, 0, 0]answer[0] 表示活跃时长为1分钟的人有 0 人answer[1] 表示活跃时长为2分钟的人有 2 人answer[2] 表示活跃时长为3分钟的人有 0 人answer[3] 表示活跃时长为4分钟的人有 0 人answer[4] 表示活跃时长为5分钟的人有 0 人 这就是题目要求的数组，题目可以用 Hash 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) &#123; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; Minutes; for (auto&amp; log : logs) &#123; int i = log[0]; int time = log[1]; Minutes[i].insert(time); &#125; vector&lt;int&gt; answer(k); for (auto&amp; [_, ts] : Minutes) &#123; ++answer[ts.size() - 1]; &#125; return answer; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"博客问题总结","slug":"Blog/博客问题总结","date":"2023-01-16T16:00:00.000Z","updated":"2023-02-01T04:28:47.976Z","comments":true,"path":"article/50347.html","link":"","permalink":"https://www.030215.xyz/article/50347.html","excerpt":"","text":"git 上传问题，每次上传显示没有权限，和端口错误（设置防火墙 上传文章后，可能第一篇文章无法阅读（应该是文件名不能有空格 上传操作需要频繁指令，一般三个指令（hexo三连 git 上传过程中需要进行代理（挂代理≡(▔﹏▔)≡ git 上传与连接的网络有关（我的热点上传不了(╬▔皿▔)╯，我刚开始以为是GitHub公钥出了问题，重新删了好几次密钥又重新到GitHub填写都没有完全解决解决，治标不治本⊙﹏⊙∥ 博客一迁移，博客时间全部都乱了变成一样的了o_o …. 为了网站性能，去掉了所有花里胡哨的的CSS以及JS (╯°□°）╯︵ ┻━┻模糊效果、透明效果、大背景、音乐以及live2D等等，这些固然好看也好玩，但是也好卡o_o ….原先个人 CPU占用率 达 20% 到 30 %，目前处于 10% 以下 最后为了体验良好，选择白折腾。 不过对于白天模式和黑夜模式的颜色渐变色以及卡片颜色做了很多修改，看起来也还蛮美观的，就这样吧美化的重点是默认(￣o￣) . z Z 以下是部分 CSS 代码，以防以后再想折腾忘记了(＠_＠;)，记得在配置文件中引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125;/* 白天模式遮罩透明 */#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125;/* 夜间模式遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125;/* 翻页按钮居中 *//* #pagination &#123; width: 100%; margin: auto;&#125; *//* 状态栏居中 *//* 一级菜单居中 */#nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important;&#125;/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important;&#125;/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child &#123; left: -125px;&#125;/* 样式 */:root &#123; --trans-light: rgba(255, 255, 255, 0.88); /*最后一个数透明值*/ --trans-dark: rgba(25, 25, 25, 0.88); --border-style: 1px solid rgb(169, 169, 169); /* --backdrop-filter: blur(5px) saturate(150%); */ /* 背景过滤器，如blur(5px) saturate(150%)表示饱和度为150%的、高斯模糊半径为5px的过滤器，这是亚克力效果的一种实现方法; */&#125;/* 首页文章卡片 */#recent-posts&gt;.recent-post-item &#123; background: var(--trans-light); /* backdrop-filter: var(--backdrop-filter); */ border-radius: 10px; border: var(--border-style);&#125;/* 首页侧栏卡片 */#aside-content .card-widget &#123; background: var(--trans-light); /* backdrop-filter: var(--backdrop-filter); */ border-radius: 10px; border: var(--border-style);&#125;/* 文章页、归档页、普通页面、分类、标签 */div#post,div#page,div#archive,div#categories,div#category,div#tag &#123; background: var(--trans-light); /* backdrop-filter: var(--backdrop-filter); */ border: var(--border-style); border-radius: 10px;&#125;/* 导航栏 */#page-header.nav-fixed #nav &#123; background: rgba(255, 255, 255, 0.75); /* backdrop-filter: var(--backdrop-filter); */&#125;[data-theme=&quot;dark&quot;] #page-header.nav-fixed #nav &#123; background: rgba(0, 0, 0, 0.7) !important;&#125;/* 夜间模式遮罩 */[data-theme=&quot;dark&quot;] #recent-posts&gt;.recent-post-item,[data-theme=&quot;dark&quot;] #aside-content .card-widget,[data-theme=&quot;dark&quot;] div#post,[data-theme=&quot;dark&quot;] div#archive,[data-theme=&quot;dark&quot;] div#page,[data-theme=&quot;dark&quot;] div#category,[data-theme=&quot;dark&quot;] div#tag &#123; background: var(--trans-dark);&#125;/* 夜间模式页脚页头遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125;/* 阅读模式 */.read-mode #aside-content .card-widget &#123; background: rgba(158, 204, 171, 0.5) !important;&#125;.read-mode div#post &#123; background: rgba(158, 204, 171, 0.5) !important;&#125;/* 夜间模式下的阅读模式 */[data-theme=&quot;dark&quot;] .read-mode #aside-content .card-widget &#123; background: rgba(25, 25, 25, 0.9) !important; color: #e4e4e4;&#125;[data-theme=&quot;dark&quot;] .read-mode div#post &#123; background: rgba(25, 25, 25, 0.9) !important; color: #e4e4e4;&#125;/* 加载条 */.pace &#123; pointer-events: none; user-select: none; z-index: 2; position: fixed; margin: auto; top: 4px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 6rem; background: #eaecf2; overflow: hidden;&#125;.pace-inactive .pace-progress &#123; opacity: 0; transition: 0.3s ease-in;&#125;.pace.pace-inactive &#123; opacity: 0; transition: 0.3s; top: -8px;&#125;.pace .pace-progress &#123; box-sizing: border-box; transform: translate3d(0, 0, 0); position: fixed; z-index: 2; display: block; position: absolute; top: 0; right: 100%; height: 100%; width: 100%; background: #49b1f5; background: linear-gradient(to right, rgb(18, 194, 233), rgb(196, 113, 237), rgb(246, 79, 89)); animation: gradient 2s ease infinite; background-size: 200%;&#125;/* 关注颜色 */#aside-content .card-info #card-info-btn:hover &#123; background-color: #96dbc6;&#125;/* [data-theme=&#x27;dark&#x27;] &#123; --card-bg: #5a4646 !important; --sidebar-bg: #421f22 !important;&#125;[data-theme=&#x27;light&#x27;] &#123; --card-bg: #fff6f6 !important;&#125;:root &#123; --scrollbar-color: #ccada3 !important; --btn-bg: #c6a99f !important; --sidebar-bg: #ffebeb;&#125; */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221/* 样式 */:root &#123; --trans-light: rgb(255 255 255 / 0%); /*最后一个数透明值*/ /* --trans-dark: rgba(25, 25, 25, 0.88); */ /* --border-style: 1px solid rgb(169, 169, 169); */ /* --backdrop-filter: blur(5px) saturate(150%); */ /* 背景过滤器，如blur(5px) saturate(150%)表示饱和度为150%的、高斯模糊半径为5px的过滤器，这是亚克力效果的一种实现方法; */&#125;/* 首页文章卡片 */#recent-posts&gt;.recent-post-item &#123; background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ border-radius: 35px !important; /* border: var(--border-style); */&#125;/* 首页侧栏卡片 */#aside-content .card-widget &#123; background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ border-radius: 35px !important; /* border: var(--border-style); */&#125;/* 文章页、归档页、普通页面、分类、标签 */div#post,div#page,div#archive,div#categories,div#category,div#tag &#123; background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ /* border: var(--border-style); */ border-radius: 35px !important;&#125;/* 导航栏 */#page-header.nav-fixed #nav &#123; background: rgba(255, 255, 255, 0) !important; /* backdrop-filter: var(--backdrop-filter); */&#125;/* [data-theme=&quot;dark&quot;] #page-header.nav-fixed #nav &#123; background: rgba(0, 0, 0, 0.7) !important;&#125; *//* 夜间模式遮罩 *//* [data-theme=&quot;dark&quot;] #recent-posts&gt;.recent-post-item,[data-theme=&quot;dark&quot;] #aside-content .card-widget,[data-theme=&quot;dark&quot;] div#post,[data-theme=&quot;dark&quot;] div#archive,[data-theme=&quot;dark&quot;] div#page,[data-theme=&quot;dark&quot;] div#category,[data-theme=&quot;dark&quot;] div#tag &#123; background: var(--trans-dark);&#125; *//* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;/* #page-header &#123; background: transparent !important;&#125; *//* 白天模式遮罩透明 */#footer::before &#123; background: transparent !important;&#125;/* #page-header::before &#123; background: transparent !important;&#125; *//* 夜间模式遮罩透明 *//* [data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; *//* 右侧功能键 */#rightside&gt;div&gt;a,#rightside&gt;div&gt;button &#123; background-color: #49b1f500 !important; color: #fff !important;&#125;:root &#123; /* 滑动条颜色 */ /* --scrollbar-color: #15161600 !important; */ /* 字体颜色 */ --font-color: #000000 !important; /* 引用颜色 */ --blockquote-color: #000000 !important; /* 引用背景颜色 */ --blockquote-bg: rgb(0 0 0 / 10%) !important; /* 搜索的标题颜色 */ --search-result-title: #ffffff !important; /* 手机版侧边栏颜色 */ --sidebar-bg: #a7a2a18f !important; /* 按钮按下去颜色 */ --btn-hover-color: #bdc1dc !important;&#125;/* 状态栏居中 *//* 一级菜单居中 *//* #nav .menus_items &#123; position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important;&#125; *//* 子菜单横向展示 *//* #nav .menus_items .menus_item:hover .menus_item_child &#123; display: flex !important;&#125; *//* 文章框大小 */#recent-posts&gt;.recent-post-item &#123; height: 11em !important;&#125;/* 搜索颜色 */.search-dialog &#123; background: #a5999975 !important;&#125;/* 单行代码颜色 */#article-container code &#123; color: #9f0000 !important;&#125;::-webkit-scrollbar &#123; width: 0px !important;&#125;#page-header.nav-fixed #nav &#123; z-index: 90 !important;&#125;#page-header.nav-fixed #nav,#page-header.not-top-img #nav &#123; box-shadow: 0 0px 0px 0px !important; background: rgb(255 255 255 / 0%) !important;&#125;.avatar-img img &#123; transition: filter 375ms ease-in .2s, transform 1s !important;&#125;/* 按钮颜色 */#pagination .page-number.current &#123; background: #b3c8de !important;&#125;/* 搜索到的字的颜色 */#local-search .search-dialog .local-search__hit-item .search-keyword &#123; color: #4fd4f1 !important;&#125;/* 加载条 */.pace &#123; pointer-events: none; user-select: none; z-index: 2; position: fixed; margin: auto; top: 4px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 6rem; background: #eaecf2; overflow: hidden;&#125;.pace-inactive .pace-progress &#123; opacity: 0; transition: 0.3s ease-in;&#125;.pace.pace-inactive &#123; opacity: 0; transition: 0.3s; top: -8px;&#125;.pace .pace-progress &#123; box-sizing: border-box; transform: translate3d(0, 0, 0); position: fixed; z-index: 2; display: block; position: absolute; top: 0; right: 100%; height: 100%; width: 100%; background: #49b1f5; background: linear-gradient(to right, rgb(18, 194, 233), rgb(196, 113, 237), rgb(246, 79, 89)); animation: gradient 2s ease infinite; background-size: 200%;&#125;/* 网站名的阴影 */#nav .site-name &#123; text-shadow: 0px 0px 0px;&#125;","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"hexo食用方法","slug":"Blog/hexo食用方法","date":"2023-01-15T16:00:00.000Z","updated":"2023-02-08T04:21:24.809Z","comments":true,"path":"article/46371.html","link":"","permalink":"https://www.030215.xyz/article/46371.html","excerpt":"","text":"文章设置 写法 解释 title 【必需】文章标题 date 【必需】文章创建日期 2022-12-12 updated 【可选】文章更新日期 tags 【可选】文章标籤 categories 【可选】文章分类 keywords 【可选】文章关键字 description 【可选】文章描述 top_img 【可选】文章顶部图片 cover 【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空) comments 【可选】显示文章评论模块(默认 true) toc 【可选】显示文章TOC(默认为设置中toc的enable配置) toc_number 【可选】显示toc_number(默认为设置中toc的number配置) toc_style_simple 【可选】显示 toc 简洁模式 copyright 【可选】显示文章版权模块(默认为设置中post_copyright的enable配置) copyright_author 【可选】文章版权模块的文章作者 copyright_author_href 【可选】文章版权模块的文章作者链接 copyright_url 【可选】文章版权模块的文章连结链接 copyright_info 【可选】文章版权模块的版权声明文字 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) katex 【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false) highlight_shrink 【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置) aside 【可选】显示侧边栏 (默认 true) sticky 填写数字，表示置顶 文章推送1234hexo cleanhexo ggulphexo d 脚本一行命令部署，根目录下新建 dp.sh 文件，写入以下内容，以后只需要在输入 ./dp.sh 即可完成部署加备份，hhh 123456789101112131415echo -e &quot;\\033[32mclear.........\\033[0m&quot;hexo clecho -e &quot;\\033[32mgenerate.........\\033[0m&quot;hexo gecho -e &quot;\\033[32mgulp.........\\033[0m&quot;gulpecho -e &quot;\\033[32mdeploy.........\\033[0m&quot;hexo decho -e &quot;\\033[32backup.........\\033[0m&quot;./push.shif [ $? -ne 0 ]; then echo -e &quot;\\033[31m fail,check your net \\033[0m&quot;else echo -e &quot;\\033[32msuccess deploy and backup\\033[0m&quot;fi 备份推送（有相关脚本以及仓库情况下 1./push.sh 文章标签外挂 以下内容仅 butterfly 主题支持，非必要不使用 折叠栏（Toggle） 代码 12345&#123;% hideToggle 点击打开 %&#125;这里可以写内容&#123;% endhideToggle %&#125; 预览 12345&#123;% hideToggle 点击打开 %&#125;这里可以写内容&#123;% endhideToggle %&#125; 选择卡（Tabs） 代码 1234567891011&#123;% tabs 样例 %&#125;&lt;!-- tab 内容1 --&gt;这里可以写内容&lt;!-- endtab --&gt;&lt;!-- tab 内容2 --&gt;这里可以写内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 预览 1234567&#123;% tabs 样例 %&#125;&lt;!-- tab 内容1 --&gt;这里可以写内容&lt;!-- endtab --&gt;&lt;!-- tab 内容2 --&gt;这里可以写内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125;","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/categories/Python/"},{"name":"编程规范","slug":"编程规范","permalink":"https://www.030215.xyz/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"},{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"},{"name":"算法基础","slug":"算法基础","permalink":"https://www.030215.xyz/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/tags/Python/"},{"name":"命名规范","slug":"命名规范","permalink":"https://www.030215.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"},{"name":"Obsidian","slug":"Obsidian","permalink":"https://www.030215.xyz/tags/Obsidian/"},{"name":"算法基础","slug":"算法基础","permalink":"https://www.030215.xyz/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"Typora","slug":"Typora","permalink":"https://www.030215.xyz/tags/Typora/"},{"name":"git","slug":"git","permalink":"https://www.030215.xyz/tags/git/"},{"name":"图床","slug":"图床","permalink":"https://www.030215.xyz/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}