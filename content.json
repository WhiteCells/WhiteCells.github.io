{"meta":{"title":"WhiteのBlog","subtitle":"欢迎ヾ(≧▽≦*)o","description":"Nothing is impossible","author":"WhiteCells","url":"https://www.030215.xyz","root":"/"},"pages":[{"title":"关于","date":"2023-02-08T07:20:15.747Z","updated":"2023-02-08T07:20:15.747Z","comments":true,"path":"about/index.html","permalink":"https://www.030215.xyz/about/index.html","excerpt":"","text":"这里是这个网站的相关内容 本站基于 hexo 框架搭建，主题butterfly在此基础上进行修改，采用双线部署 本站没有进行备案相关操作（太麻烦了╯︿╰） 本站没有进行国内的 CDN 服务（没备案 本站没有进行搜索引擎收录（暂时没必要 本站没有植入广告内容，放心食用(￣y▽￣)╭ Ohohoho…..） 站点网址：030215.xyz 站点备用网址：xuan5123.eu.org（稳定"},{"title":"归档","date":"2023-02-08T07:21:48.589Z","updated":"2023-02-08T07:21:48.589Z","comments":true,"path":"archives/index.html","permalink":"https://www.030215.xyz/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-14T05:34:26.814Z","updated":"2023-02-14T05:34:26.814Z","comments":true,"path":"css/custom.css","permalink":"https://www.030215.xyz/css/custom.css","excerpt":"","text":"/* 样式 */ :root { --trans-light: rgb(255 255 255 / 0%); /*最后一个数透明值*/ /* --trans-dark: rgba(25, 25, 25, 0.88); */ /* --border-style: 1px solid rgb(169, 169, 169); */ /* --backdrop-filter: blur(5px) saturate(150%); */ /* 背景过滤器，如blur(5px) saturate(150%)表示饱和度为150%的、高斯模糊半径为5px的过滤器，这是亚克力效果的一种实现方法; */ } /* 首页文章卡片 */ #recent-posts>.recent-post-item { background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ border-radius: 35px !important; /* border: var(--border-style); */ } /* 首页侧栏卡片 */ #aside-content .card-widget { background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ border-radius: 35px !important; /* border: var(--border-style); */ } /* 文章页、归档页、普通页面、分类、标签 */ div#post, div#page, div#archive, div#categories, div#category, div#tag { background: var(--trans-light) !important; /* backdrop-filter: var(--backdrop-filter); */ /* border: var(--border-style); */ border-radius: 35px !important; } /* 导航栏 */ #page-header.nav-fixed #nav { background: rgba(255, 255, 255, 0) !important; /* backdrop-filter: var(--backdrop-filter); */ } /* [data-theme=\"dark\"] #page-header.nav-fixed #nav { background: rgba(0, 0, 0, 0.7) !important; } */ /* 夜间模式遮罩 */ /* [data-theme=\"dark\"] #recent-posts>.recent-post-item, [data-theme=\"dark\"] #aside-content .card-widget, [data-theme=\"dark\"] div#post, [data-theme=\"dark\"] div#archive, [data-theme=\"dark\"] div#page, [data-theme=\"dark\"] div#category, [data-theme=\"dark\"] div#tag { background: var(--trans-dark); } */ /* 页脚与头图透明 */ #footer { background: transparent !important; } /* #page-header { background: transparent !important; } */ /* 白天模式遮罩透明 */ #footer::before { background: transparent !important; } /* #page-header::before { background: transparent !important; } */ /* 夜间模式遮罩透明 */ /* [data-theme=\"dark\"] #footer::before { background: transparent !important; } [data-theme=\"dark\"] #page-header::before { background: transparent !important; } */ /* 右侧功能键 */ #rightside>div>a, #rightside>div>button { background-color: #49b1f500 !important; color: #fff !important; } :root { /* 滑动条颜色 */ /* --scrollbar-color: #15161600 !important; */ /* 字体颜色 */ --font-color: #000000 !important; /* 引用颜色 */ --blockquote-color: #000000 !important; /* 引用背景颜色 */ --blockquote-bg: rgb(0 0 0 / 10%) !important; /* 搜索的标题颜色 */ --search-result-title: #ffffff !important; /* 手机版侧边栏颜色 */ --sidebar-bg: #a7a2a18f !important; /* 按钮按下去颜色 */ --btn-hover-color: #bdc1dc !important; } /* 状态栏居中 */ /* 一级菜单居中 */ /* #nav .menus_items { position: absolute !important; width: fit-content !important; left: 50% !important; transform: translateX(-50%) !important; } */ /* 子菜单横向展示 */ /* #nav .menus_items .menus_item:hover .menus_item_child { display: flex !important; } */ /* 文章框大小 */ #recent-posts>.recent-post-item { height: 11em !important; } /* 搜索颜色 */ .search-dialog { background: #a5999975 !important; } /* 单行代码颜色 */ #article-container code { color: #9f0000 !important; } ::-webkit-scrollbar { width: 0px !important; } #page-header.nav-fixed #nav { z-index: 90 !important; } #page-header.nav-fixed #nav, #page-header.not-top-img #nav { box-shadow: 0 0px 0px 0px !important; background: rgb(255 255 255 / 0%) !important; } .avatar-img img { transition: filter 375ms ease-in .2s, transform 1s !important; } /* 按钮颜色 */ #pagination .page-number.current { background: #b3c8de !important; } /* 搜索到的字的颜色 */ #local-search .search-dialog .local-search__hit-item .search-keyword { color: #4fd4f1 !important; } /* 加载条 */ /* .pace { pointer-events: none; user-select: none; z-index: 2; position: fixed; margin: auto; top: 4px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 6rem; background: #eaecf2; overflow: hidden; } .pace-inactive .pace-progress { opacity: 0; transition: 0.3s ease-in; } .pace.pace-inactive { opacity: 0; transition: 0.3s; top: -8px; } .pace .pace-progress { box-sizing: border-box; transform: translate3d(0, 0, 0); position: fixed; z-index: 2; display: block; position: absolute; top: 0; right: 100%; height: 100%; width: 100%; background: #49b1f5; background: linear-gradient(to right, rgb(18, 194, 233), rgb(196, 113, 237), rgb(246, 79, 89)); animation: gradient 2s ease infinite; background-size: 200%; } */ /* 网站名的阴影 */ #nav .site-name { text-shadow: 0px 0px 0px; } #aside-content .card-info .card-info-social-icons i:hover { transform: rotate(180deg); }"},{"title":"","date":"2023-02-01T07:31:04.924Z","updated":"2023-02-01T07:31:04.924Z","comments":true,"path":"css/progress_bar.css","permalink":"https://www.030215.xyz/css/progress_bar.css","excerpt":"","text":".pace { -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; z-index: 2000; position: fixed; margin: auto; top: 10px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 4rem; background: #eaecf2; border: 1px #e3e8f7; overflow: hidden; } .pace-inactive .pace-progress { opacity: 0; transition: 0.3s ease-in; } .pace .pace-progress { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); -o-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); max-width: 200px; position: absolute; z-index: 2000; display: block; top: 0; right: 100%; height: 100%; width: 100%; background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab); animation: gradient 1.5s ease infinite; background-size: 200%; } .pace.pace-inactive { opacity: 0; transition: 0.3s; top: -8px; } @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } } .loading-img { background: url(https://s1.vika.cn/space/2023/01/29/dafe1b1278d4468c8a65a88962ed0195) no-repeat center center; background-size: cover; }"},{"title":"分类","date":"2023-02-08T07:21:07.817Z","updated":"2023-02-08T07:21:07.817Z","comments":true,"path":"categories/index.html","permalink":"https://www.030215.xyz/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2023-02-08T06:55:08.137Z","updated":"2023-02-08T06:55:08.137Z","comments":true,"path":"friends/index.html","permalink":"https://www.030215.xyz/friends/index.html","excerpt":"链接","text":"链接 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"链接","date":"2023-01-16T07:54:47.000Z","updated":"2023-01-31T07:05:04.092Z","comments":true,"path":"link/index.html","permalink":"https://www.030215.xyz/link/index.html","excerpt":"","text":""},{"title":"","date":"2023-01-31T04:32:53.998Z","updated":"2023-01-31T04:32:53.998Z","comments":true,"path":"js/title.js","permalink":"https://www.030215.xyz/js/title.js","excerpt":"","text":"//动态标题 var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { //离开当前页面时标签显示内容 document.title = '(＞﹏＜)别走呀'; clearTimeout(titleTime); } else { //返回当前页面时标签显示内容 document.title = '(=•ω＜=)☆回来了'; //两秒后变回正常标题 titleTime = setTimeout(function () { document.title = OriginTitile; }, 1000); } });"},{"title":"链接","date":"2023-01-17T01:41:14.000Z","updated":"2023-02-05T02:13:30.201Z","comments":true,"path":"links/index.html","permalink":"https://www.030215.xyz/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-08T07:23:34.389Z","updated":"2023-02-08T07:23:34.389Z","comments":true,"path":"tags/index.html","permalink":"https://www.030215.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"206. 反转链表(简单)","slug":"LeetCode必刷题/2、链表/4-206. 反转链表","date":"2023-03-05T16:00:00.000Z","updated":"2023-03-05T09:04:27.696Z","comments":true,"path":"article/e0f9ad28.html","link":"","permalink":"https://www.030215.xyz/article/e0f9ad28.html","excerpt":"","text":"题目描述 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 解题过程","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode必刷题/链表","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.030215.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"707. 设计链表(中等)","slug":"LeetCode必刷题/2、链表/3-707. 设计链表","date":"2023-03-04T16:00:00.000Z","updated":"2023-03-05T07:55:55.056Z","comments":true,"path":"article/610c6f5a.html","link":"","permalink":"https://www.030215.xyz/article/610c6f5a.html","excerpt":"","text":"题目描述 707. 设计链表 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： 1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 get, addAtHead, addAtTail, addAtIndex 和 deleteAtIndex 的操作次数不超过 2000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class MyLinkedList &#123;public: MyLinkedList() &#123; _head = new LinkedList(0); _size = 0; &#125; // 返回下标数据 int get(int index) &#123; if (index &lt; 0 || index &gt;= this-&gt;_size) &#123; return -1; &#125; LinkedList* cur_node = _head-&gt;next; for (int i = 0; i &lt; index; ++i) &#123; cur_node = cur_node-&gt;next; &#125; return cur_node-&gt;val; &#125; // 头插 void addAtHead(int val) &#123; LinkedList* new_node = new LinkedList(val); new_node-&gt;next = _head-&gt;next; _head-&gt;next = new_node; ++_size; &#125; // 尾插 void addAtTail(int val) &#123; LinkedList* new_node = new LinkedList(val); LinkedList* cur_node = _head; // 记录 _head，不用单独考虑 _head-&gt;next == nullptr 情况 while (cur_node-&gt;next != nullptr) &#123; cur_node = cur_node-&gt;next; &#125; cur_node-&gt;next = new_node; ++_size; &#125; // 下标插入 void addAtIndex(int index, int val) &#123; if (index &gt; this-&gt;_size) &#123; // index &gt; _size，适用 index == _size，就是尾插的形式 return; &#125; if (index &lt; 0) &#123; index = 0; &#125; LinkedList* new_node = new LinkedList(val); LinkedList* cur_node = _head; // 记录 _head，适用 index == 0 时 for (int i = 0; i &lt; index; ++i) &#123; cur_node = cur_node-&gt;next; &#125; new_node-&gt;next = cur_node-&gt;next; cur_node-&gt;next = new_node; ++_size; &#125; // 下标删除 void deleteAtIndex(int index) &#123; if (index &lt; 0 || index &gt;= this-&gt;_size) &#123; return; &#125; LinkedList* cur_node = _head; // 记录 _head，适用 index == 0 时 for (int i = 0; i &lt; index; ++i) &#123; cur_node = cur_node-&gt;next; &#125; LinkedList* temp = cur_node-&gt;next; cur_node-&gt;next = temp-&gt;next; delete temp; --_size; &#125; // 打印 void printLinkedList() &#123; if (_head-&gt;next == nullptr) return; LinkedList* cur_node = _head-&gt;next; // 记录 _head-&gt;next 头结点不输出 while (cur_node != nullptr) &#123; cout &lt;&lt; cur_node-&gt;val &lt;&lt; &quot; &quot;; cur_node = cur_node-&gt;next; &#125; &#125;private: struct LinkedList &#123; int val; LinkedList* next; LinkedList(int val): val(val), next(nullptr) &#123;&#125; &#125;; LinkedList* _head; int _size;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode必刷题/链表","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.030215.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"83. 删除排序链表中的重复元素(简单)","slug":"LeetCode必刷题/2、链表/2-83. 删除排序链表中的重复元素","date":"2023-03-03T16:00:00.000Z","updated":"2023-03-04T11:05:58.449Z","comments":true,"path":"article/54635.html","link":"","permalink":"https://www.030215.xyz/article/54635.html","excerpt":"","text":"题目描述 83. 删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例 1： 12输入：head = [1,1,2]输出：[1,2] 示例 2： 12输入：head = [1,1,2,3,3]输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 解题过程第一次写的代码： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return nullptr; ListNode* left = head; ListNode* right = head-&gt;next; while (right != nullptr) &#123; if (left-&gt;val == right-&gt;val) &#123; left-&gt;next = right-&gt;next; left = right-&gt;next; if (right-&gt;next != nullptr) &#123; right = left-&gt;next; &#125; else &#123; break; &#125; &#125; else &#123; left = left-&gt;next; right = right-&gt;next; &#125; &#125; return head; &#125;&#125;; 存在 bug，测试用例 [1, 1, 1] 未通过 这里出现的问题在于当两个元素相等时，向后移动 left 指针，而代码中 right 指针有等于 left 指针的下一个指针，这个时候就会造成忽略 其实只需要一个指针就可以了 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* node = head; while (node &amp;&amp; node-&gt;next) &#123; if (node-&gt;val == node-&gt;next-&gt;val) &#123; ListNode* temp = node-&gt;next; node-&gt;next = temp-&gt;next; delete temp; &#125; else &#123; node = node-&gt;next; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode必刷题/链表","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.030215.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"兔子数列思路","slug":"编程随想/兔子数列","date":"2023-03-02T16:00:00.000Z","updated":"2023-03-05T02:00:30.204Z","comments":true,"path":"article/45f71455z.html","link":"","permalink":"https://www.030215.xyz/article/45f71455z.html","excerpt":"","text":"兔子数列（斐波那契数列）：1、1、2、3、5、8、13、21、34、… 后一项等于前两项之和，第一项和第二项为 1 下面是公式$$f(n)&#x3D;\\begin{cases}1,&amp;\\text{n &lt;&#x3D; 2}\\\\\\f(n-1)+f(n-2),&amp;\\text{n &gt;&#x3D; 3}\\end{cases}$$ 看到这种有相同方法的公式，很容易让人想到去使用递归。 下面是递归求解代码： 12345// 兔子数列-递归方式long long Fibonacci(int num) &#123; if (num == 1 || num == 2) return 1; return Fibonacci(num - 1) + Fibonacci(num - 2);&#125; 递归的方法在数据较大的时候，时间复杂度很高，大概 50 项左右的时候就要算很久。 但是使用数组的方式就可以很快的算出来。 数组的思路： 图上一次循环就能得到三个数，求第 6 项只用循环 1 次。 现在可以通过这种方式算出数组，但是问题是返回第几项的具体位置（实际物理下标）和循环多少次（循环次数）。 逻辑下标是要输入的 num，物理下标是数组的下标 index。 对物理下标进行操作 index / 3 可以得到 循环次数 index % 3 可以得到 实际物理下标 因为我们输入的是逻辑下标，比物理下标大1，所以我们对逻辑下标进行减一操作 num-1 在把他变成物理下标去获得循环次数和实际物理下标。 (num - 1) / 3 得到 循环次数 (num - 1) % 3 得到 实际物理下标 下面是数组求解代码： 123456789101112// 兔子数列-数组的方式求解long long Fibonacci(int num) &#123; if (num == 1 || num == 2) return 1; if (num == 3) return 2; long long rabbit_arr[3] = &#123; 1, 1, 2 &#125;; for (int i = 0, index = 0; i &lt; (num - 1) / 3; ++i) &#123; rabbit_arr[0] = rabbit_arr[1] + rabbit_arr[2]; rabbit_arr[1] = rabbit_arr[0] + rabbit_arr[2]; rabbit_arr[2] = rabbit_arr[0] + rabbit_arr[1]; &#125; return rabbit_arr[(num - 1) % 3];&#125; 下面是递归的方式和数组的方式进行比较： 通过上面的测试可以感受到递归方法在数据较大时是很慢的。 既然运用到后一项等于前两项之和，就可以再次简化代码。 下面是简化后的代码： 123456789101112// 兔子数列-简化版long long Fibonacci(int num) &#123; if (num == 1 || num == 2) return 1; if (num == 2) return 2; long long a = 1, b = 1, c = 2; for (int i = 0; i &lt; num - 3; ++i) &#123; a = b; // b 向前移动 b = c; // c 向前移动 c = a + b; // 更新 c &#125; return c;&#125; 但是这次简化之后，假设求第 6 项，那么就要循环 3 次了，时间复杂度要稍高，相较于数组的代码可读性也稍低。","categories":[{"name":"编程随想","slug":"编程随想","permalink":"https://www.030215.xyz/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://www.030215.xyz/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"}]},{"title":"203. 移除链表元素(简单)","slug":"LeetCode必刷题/2、链表/1-203. 移除链表元素","date":"2023-03-02T16:00:00.000Z","updated":"2023-03-05T08:19:41.726Z","comments":true,"path":"article/9a8d3ba6.html","link":"","permalink":"https://www.030215.xyz/article/9a8d3ba6.html","excerpt":"","text":"题目描述 203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 解题过程第一次写的代码： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; // 删除头结点的 val == val while (head-&gt;val == val &amp; head != nullptr) &#123; ListNode* temp = head; // 临时指针变量接管 头结点 head = head-&gt;next; // 更改头结点的指向 delete temp; // 删除头结点 &#125; ListNode* cur_node = head; while (cur_node != nullptr &amp; cur_node-&gt;next != nullptr) &#123; // 删除非头结点 val == val if (cur_node-&gt;next-&gt;val == val) &#123; ListNode* temp = cur_node-&gt;next; // 临时指针变量接管 非头结点 cur_node-&gt;next = cur_node-&gt;next-&gt;next; // 被删除结点的前一个结点指向被删除结点的后一个结点 delete temp; // 删除非头结点 &#125; // 不相等的时候 cur_node 向后移动 else &#123; cur_node = cur_node-&gt;next; &#125; &#125; return head; &#125;&#125;; bug 分析 第一个 while 循环的条件出现了 bug，我上来就先将 head 结点的数据域调了出来与 val 进行比较，再对 head 进行判空操作，bug 就出现在如果当 head 为空的时候，就是对空指针进行了成员访问，所以要先进行判空操作 runtime error: member access within null pointer of type ‘ListNode’ 解决方法： 1while (head != nullptr &amp;&amp; head-&gt;val == val) // 先判断是否为空，如果为空，就不用访问其成员 第二个 bug 上面已经修复了，就是 &amp;&amp; 和 &amp;，这里应该使用 &amp;&amp; 修改后的代码： 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; // 删除头结点的 val == val // 先判断头结点是否为空，再判断头结点 val 是否等于 val while (head != nullptr &amp;&amp; head-&gt;val == val) &#123; ListNode* temp = head; // 临时指针变量接管 头结点 head = head-&gt;next; // 更改头结点的指向 delete temp; // 删除头结点 &#125; ListNode* cur_node = head; // 先判断当前结点是否为空，再判断下一个结点是否为空 while (cur_node != nullptr &amp;&amp; cur_node-&gt;next != nullptr) &#123; // 删除非头结点 val == val if (cur_node-&gt;next-&gt;val == val) &#123; ListNode* temp = cur_node-&gt;next; // 临时指针变量接管 非头结点 cur_node-&gt;next = cur_node-&gt;next-&gt;next; // 被删除结点的前一个结点指向被删除结点的后一个结点 delete temp; // 删除非头结点 &#125; // 不相等的时候 cur_node 向后移动 else &#123; cur_node = cur_node-&gt;next; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode必刷题/链表","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.030215.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"59. 螺旋矩阵 II(中等)","slug":"LeetCode必刷题/1、数组/5-59. 螺旋矩阵 II","date":"2023-02-28T16:00:00.000Z","updated":"2023-03-04T11:07:48.984Z","comments":true,"path":"article/5e3ed6f6.html","link":"","permalink":"https://www.030215.xyz/article/5e3ed6f6.html","excerpt":"","text":"题目描述 59. 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 12输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if (n == 1) return vector&lt;vector&lt;int&gt;&gt;(1, vector&lt;int&gt;(1, 1)); // &#123;&#123;1&#125;&#125; int count = 1; // 初始化矩阵的数 int offset = 1; // 右边界的减少量 int mid = n / 2; // 为奇数时中间位置 int loop = n / 2; // 循环次数 int i = 0, j = 0; // 循环体内的循环变量 int startx = 0, starty = 0; // 每一圈的起点位置 vector&lt;vector&lt;int&gt;&gt; v(n, vector&lt;int&gt;(n)); while (loop--) &#123; i = startx; j = starty; // 模拟上行 从左到右 for (j = starty; j &lt; n - offset; ++j) &#123; v[startx][j] = count++; &#125; // 模拟右列 从上到下 for (i = startx; i &lt; n - offset; ++i) &#123; v[i][j] = count++; &#125; // 模拟下行 从右到左 for (; j &gt; starty; --j) &#123; v[i][j] = count++; &#125; // 模拟左列 从下到上 for (; i &gt; startx; --i) &#123; v[i][j] = count++; &#125; // 调整起始位置 ++startx; ++starty; // 调整右边界 ++offset; &#125; // n 为奇数 if (n % 2) &#123; v[mid][mid] = count; // count 在上面循环中最后一次已经自增了一次 &#125; return v; &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"LeetCode必刷题/数组","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.030215.xyz/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"209. 长度最小的子数组(中等)","slug":"LeetCode必刷题/1、数组/4-209.长度最小的子数组","date":"2023-02-27T16:00:00.000Z","updated":"2023-03-04T11:05:43.688Z","comments":true,"path":"article/244009ff.html","link":"","permalink":"https://www.030215.xyz/article/244009ff.html","excerpt":"","text":"滑动窗口 209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 12345678910111213141516171819class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int ret_len = INT32_MAX; // 窗口长度返回值 int sub_len = 0; // 窗口长度 int sum = 0; // 窗口和 int j = 0; // 窗口的左边界 for (int i = 0; i &lt; nums.size(); ++i) &#123; sum += nums[i]; // 计算窗口的和 while (sum &gt;= target) &#123; sub_len = i - j + 1; // 更新窗口长度 ret_len = ret_len &gt; sub_len ? sub_len : ret_len; // 更新返回值 sum -= nums[j]; // 更新窗口的和 ++j; // 更新窗口左边界 &#125; &#125; return ret_len == INT32_MAX ? 0 : ret_len; // 窗口没有调整的时候需要返回 0 &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"LeetCode必刷题/数组","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.030215.xyz/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"350. 两个数组的交集 II(简单)","slug":"LeetCode/350. 两个数组的交集 II","date":"2023-02-26T16:00:00.000Z","updated":"2023-03-05T00:52:53.944Z","comments":true,"path":"article/2f4f76e7.html","link":"","permalink":"https://www.030215.xyz/article/2f4f76e7.html","excerpt":"","text":"题目描述 350. 两个数组的交集 II 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 ***进阶*： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题过程第一次写的代码： 1234567891011class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; v; for (int left = 0, right = 0; left &lt; nums1.size(); ++left) &#123; if (right == nums2.size()) break; if (nums1[left] == nums2[right]) v.push_back(nums2[right++]); &#125; return v; &#125;&#125;; 运用的双指针，左指针随着循环移动，固定右指针也就是nums2的下标，满足条件的时候存放数据加移动右指针，当nums2越界后退出循环。 bug 分析 当nums2的长度大于nums1长度的时候，当不满足条件的时候，移动的是nums1的下标，num2下标不移动，循环就会结束了。 解决办法：指针移动不使用 for 进行调整双指针，满足相等条件指针同时向右移动，不满足条件时，小的指针那一边进行向后移动。 nums1 和 nums2不是有序 双指针一直向右跑，导致左边的一些交集的值被忽略。 所以在使用双指针之前需要排序 修改后的代码： 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; v; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int index1 = 0; int index2 = 0; while (index1 &lt; nums1.size() &amp;&amp; index2 &lt; nums2.size()) &#123; if (nums1[index1] == nums2[index2]) &#123; v.push_back(nums1[index1++]); ++index2; &#125; else if (nums1[index1] &lt; nums2[index2]) &#123; ++index1; &#125; else if (nums1[index1] &gt; nums2[index2]) &#123; ++index2; &#125; &#125; return v; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.030215.xyz/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"977. 有序数组的平方(简单)","slug":"LeetCode必刷题/1、数组/3-977.有序数组的平方","date":"2023-02-26T16:00:00.000Z","updated":"2023-03-04T03:38:30.956Z","comments":true,"path":"article/f93f9cdd.html","link":"","permalink":"https://www.030215.xyz/article/f93f9cdd.html","excerpt":"","text":"题目描述 977. 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int left = 0; int right = nums.size() - 1; int index = nums.size() - 1; vector&lt;int&gt; ret_v(nums.size()); for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123; ret_v[index--] = nums[left] * nums[left]; left++; &#125; else &#123; ret_v[index--] = nums[right] * nums[right]; right--; &#125; &#125; return ret_v; &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"LeetCode必刷题/数组","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.030215.xyz/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"27. 移除元素(简单)","slug":"LeetCode必刷题/1、数组/2-27.移除元素","date":"2023-02-25T16:00:00.000Z","updated":"2023-03-04T04:11:31.054Z","comments":true,"path":"article/de85b68f.html","link":"","permalink":"https://www.030215.xyz/article/de85b68f.html","excerpt":"","text":"题目描述 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int slow = 0; for (int fast = 0; fast &lt; nums.size(); fast++) &#123; if (val != nums[fast]) &#123; nums[slow++] = nums[fast]; &#125; &#125; return slow; &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"LeetCode必刷题/数组","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.030215.xyz/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"704. 二分查找(简单)","slug":"LeetCode必刷题/1、数组/1-704.二分查找","date":"2023-02-24T16:00:00.000Z","updated":"2023-03-04T04:11:34.118Z","comments":true,"path":"article/749fe85e.html","link":"","permalink":"https://www.030215.xyz/article/749fe85e.html","excerpt":"","text":"题目描述 704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 二分查找的使用条件 首先这个序列必须是有序的 这个序列无重复的元素（重复元素会导致返回下标不统一 12345678910111213class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; else return mid; &#125; return -1; &#125;&#125;;","categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"LeetCode必刷题/数组","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"https://www.030215.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"Windows下Python环境安装","slug":"Python/Python环境","date":"2023-02-12T16:00:00.000Z","updated":"2023-02-13T02:38:22.054Z","comments":true,"path":"article/88c3d0c4.html","link":"","permalink":"https://www.030215.xyz/article/88c3d0c4.html","excerpt":"","text":"下载安装包 Welcome to Python.org 勾选 Add python.exe to PATH，不勾选这个需要在系统环境变量中去配置。 选择 Customize installation 自定义安装，然后 Next 修改安装路径 最后 install 安装 完成后选择 Disable path length limit 检查安装是否成功，在 cmd 窗口输入 python，出现以下结果，即为安装完成。 vscode 配置 Python 环境 打开VScode安装 Python 插件安装完毕后重启VScode 在 VsCode 中新建文件后缀名为 .py 控制台是外部还是内部，可以通过 launch.json 文件进行调整，在左侧菜单栏，选择 运行和调试点击 创建launch.json 文件，点击 python file，将文件中的 &quot;console&quot; 的值 integratedTerminal 换成 externalTerminal","categories":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/tags/Python/"}]},{"title":"Python语法","slug":"Python/Python语法","date":"2023-02-12T16:00:00.000Z","updated":"2023-03-04T04:10:59.994Z","comments":true,"path":"article/a378bd8e.html","link":"","permalink":"https://www.030215.xyz/article/a378bd8e.html","excerpt":"","text":"字面量 在代码中可以被写下来的固定的值，称为字面量 类型 描述 说明 数字（Number） - 整数（int）- 浮点数（float）- 复数（complex）- 布尔（bool） 整数：1、0、2浮点数：1.10、2.21复数：1+2j，以 j 结尾布尔：true 为 1 、false 为 0 字符串（string） 描述文本的一种数据类型 任意数量字符组成“teststringcase” 列表（List） 有序的可变序列 有序记录数据 元组（Tuple） 有序的不可变序列 记录不可变的数据集合 集合（set） 无序不重复集合 不重复的数据集合 字典（Dictionary） 无序键值对集合 可无需记录键值对数据集合 注释123456&quot;&quot;&quot;这里写多行注释这里写多行注释&quot;&quot;&quot;print(&quot;测试注释案例&quot;) # 这里写单行注释 变量变量名称 = 变量的值 print 输出数据 1print(&quot;内容1&quot;, &quot;内容2&quot;, &quot;内容3&quot;) # 用逗号分隔 1234567891011//对变量进行修改// test.cppint value = 100;value -= 10;std::cout &lt;&lt; value &lt;&lt; std::endl; // value == 90// test.pyvalue = 100value -= 10print(value) # value == 90 数据类型1type() # 查看数据类型，括号里写数据 数据类型转换 函数 说明 int(x) 转化为 int float(x) 转化为 float str(x) 转化为 string complex(x) 转化为复数类型 complex(x, y) 转化为一个复数类型，x为实数，y为虚数 标识符 编程的老生常谈问题 变量名 方法名 类名 这些名称需要用标识符去命名 标识符规则 内容限定 数字（不能以数字开头 字母 下划线 中文（不建议 大小写区分 关键字不能使用 运算符 算数运算符 运算符 描述 说明 + 加 … - 减 … * 乘 … &#x2F; 除 … &#x2F;&#x2F; 取整除 3 &#x2F;&#x2F; 2 结果 1、3.0 &#x2F;&#x2F; 2.0 结果 1.0 % 取余 … ** 指数 2 ** 10 结果 1024 赋值运算符 运算符 描述 &#x3D; 赋值运算符 复合赋值运算符 运算符 描述 +&#x3D; 加法赋值运算符 -&#x3D; 减法赋值运算符 *&#x3D; 乘法赋值运算符 &#x2F;&#x3D; 除法赋值运算符 %&#x3D; 取模赋值运算符 **&#x3D; 幂赋值运算符 &#x2F;&#x2F;&#x3D; 取整除赋值运算符 字符串扩展字符串的三种定义 单引号定义法：word &#x3D; ‘helloworld’ 双引号定义法：word &#x3D; “helloworld” 三引号定义法：word &#x3D; “””helloworld””” 三引号不用变量去接受就是注释，用变量接受后就是字符串 字符串的拼接通过加号运算符进行拼接 123str1 = &quot;hello&quot;str2 = &quot;world&quot;str3 = str1 + str2 # helloworld 字符串格式化方法1：使用 %s 字符串和变量完成拼接，使用 %s 123number = 10message = &quot;stringmessage %s&quot; % numberprint(message) # stringmessage 10 %占位符 %变量 占位符种类 int (%d) float (%f) string (%s) 方法2： 通过语法：f&quot;内容&#123;变量&#125;&quot; 的格式快速格式化，f 和 双引号之间不要有空格 不在意类型时 无精度要求时 123name = &quot;A&quot;age = 19print(f&quot;姓名:&#123;name&#125;年龄:&#123;age&#125;&quot;) 格式化精度控制使用辅助符号 m、n 来控制数据的宽度和精度 m 控制宽度，要求是数字（很少使用），设置的宽度小于原本的宽度，则无效 .n，控制小数点精度，要求是数字，会进行四舍五入 案例 1234number = 10print(&quot;%5d&quot; % number) # [空格][空格][空格]10print(&quot;%.2f&quot; % number) # 10.00 表达式进行格式化123print(&quot;1.1 * 1.1 = %.2f&quot; % (1.1 * 1.1)) # 1.21print(f&quot;1.1 * 1.1 = &#123;1.1 * 1.1&#125;&quot;) # 1.2100000000000002print(&quot;类型名: %s&quot; % type(&quot;测试&quot;)) # &lt;class &#x27;str&#x27;&gt; 数据输入input 函数 从键盘获取输入，使用一个变量接受数据 12get_number = input() # 获取键盘输出的值print(get_number) # 键盘获取的值 输入的数据都会是 字符串 类型 想要变成其他类型需要进行类型转换 判断语句比较运算符 &#x3D;&#x3D;、!&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D; if12if 条件: # 执行内容(注意缩进) if else1234if 条件: # 执行内容else: # 执行内容 if elif else12345678if 条件1: # 执行内容elif 条件2: # 执行内容elif 条件3: # 执行内容else 条件4: # 执行内容 判断语句嵌套1234567if 条件1: if 条件2: # 执行代码 elif 条件3: # 执行代码 else: # 执行代码 while 循环123while 条件: # 执行代码 # 条件操作 for循环基础语法1234567for 临时变量 in 序列类型: # 执行代码 # teststr1 = &quot;codecase&quot;for c in str1: print(c) # c\\no\\nd\\ne\\nc\\na\\ns\\ne\\n range 语句1range(num) 获取一个从 0 开始，到 num - 1 结束的数字序列 range(5) 数据为 [0,1,2,3,4] 1range(num1, num2) 获取一个从 num1 开始，到 num2 - 1 结束的数字序列 range(2, 4) 数据为 [2,3] 1range(num1, num2, step) 获取一个从 num1 开始，到 num2 - 1结束的数字序列 step 表示步长，默认为 1，上面的 -1 就是 -step range(3, 9, 3) 数据为 [3, 6] 配合 for 使用 12for i in range(0, 10, 2): # 相当于 for (int i = 0; i &lt; 10; i += 2) # 执行代码 break 和 continuebreak 直接结束循环 continue 结束本次循环，开始下一次循环 函数定义123def 函数名(传入参数): # 函数体 return 返回值 传入参数123456# 函数的定义def AddTwoNumber(val1, val2): print(f&quot;&#123;val1&#125; + &#123;val2&#125; = &#123;val1 + val2&#125;&quot;)# 函数的调用AddTwoNumber(10, 20) # 30 返回值1234def AddTwoNumber(val1, val2): return val1 + val2print(AddTwoNumber(10, 20)) # 30 None 类型 Python 中有一个特别的字面量：None 类型：&lt;class ‘NoneType’&gt; 没有返回值的函数实际上返回的是这个字面量 123456def test(): print(&quot;test&quot;)test_ret = test()print(test_ret) # Noneprint(type(test_ret)) # &lt;class &#x27;NoneType&#x27;&gt; None 表示空，在逻辑上表示假 说明文档12345678def func(a, b): &quot;&quot;&quot; :param a: 形参 a 的说明 :param b: 形参 b 的说明 :return: 返回值的说明 &quot;&quot;&quot; # 函数体 return 返回值 数据容器List定义123456789# 字面量[元素1, 元素2, 元素3, 元素4]# 定义变量变量名称 = [元素1, 元素2, 元素3, 元素4]# 定义空列表变量名称 = []变量名称 = list() 测试代码 12direction_key = [&quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;] # [&#x27;up&#x27;, &#x27;down&#x27;, &#x27;left&#x27;, &#x27;right&#x27;]print(direction_key, &quot;\\n&quot;, type(direction_key)) # &lt;class &#x27;list&#x27;&gt; 列表中存储的数据类型是不受限制的 嵌套测试 12number_list = [[1,3,4], [3,5,8]] # [[1,3,4], [3,5,8]]print(number_list, &quot;\\n&quot;, type(number_list)) # &lt;class &#x27;list&#x27;&gt; 列表索引 下标索引12number_list = [[1,2,3], [4, 5, 6], [7, 8, 9]]print(number_list[0][0], number_list[1][1]) # 1 5 下标反向索引123number_list = [[1,2,3], [4, 5, 6], [7, 8, 9]]print(number_list[-1][-1]) # 9print(number_list[-2][-1]) # 6 列表常见操作方法查询功能功能：查找指定元素在列表的下标，找不到就报错 ValueError 使用方法 123number_list = [1, 2, 3, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]print(number_list.index(3)) # 2print(number_list.index(4)) # ValueError 修改功能使用方法 1234number_list = [3, 1, 2]number_list[0] = 0number_list[-1] = 5print(number_list) # [0, 1, 5] 插入元素使用方法 123number_list = [1, 3, 4]number_list.insert(1, 2) # 下标 1 的位置上插入 2print(number_list) # [1, 2, 3, 4] 追加元素使用方法 1234567891011# 追加单个元素number_list = [1, 2, 3]number_list.append(4) # 结尾加上 4print(number_list) # [1, 2, 3, 4]# 追加其他数据容器number_list1 = [1, 2, 3]number_list2 = [4, 5, 6]number_list1.extend(number_list2) # number_list1 后追加 number_list2print(number_list1) # [1, 2, 3, 4, 5, 6]# number_list1.extend([7, 8, 9])# print(number_list1) # [1, 2, 3, 7, 8, 9] 删除元素使用方法 1234567number_list = [1, 2, 3, 4, 5, 6]del number_list[1]print(number_list) # [1, 3, 4, 5, 6] number_list.pop(3)print(number_list) # [1, 3, 4, 6] 删除某一元素在列表中的第一个匹配项使用方法 123number_list = [1, 2, 3, 4, 5]number_list.remove(2)print(number_list) # [1, 2, 4, 5] 清空列表内容使用方法 123number_list = [1, 2, 3, 4, 5]number_list.clear()print(number_list) # []","categories":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/tags/Python/"}]},{"title":"浅谈C++命名规范","slug":"习惯/编码风格","date":"2023-02-11T16:00:00.000Z","updated":"2023-03-05T04:48:37.264Z","comments":true,"path":"article/1c6fe11c.html","link":"","permalink":"https://www.030215.xyz/article/1c6fe11c.html","excerpt":"","text":"写在开头 良好的命名规范可以让程序源码更具有可读性，在程序出现 bug 时更容易找到问题所在。 对于很多人来说给函数、变量、常量命名无非是是件很痛苦的事。 命名要有描述性，让别人能够读懂，而不是只有自己能看懂（时间久了自己都不知道了 目前流行命名规则 小驼峰 int myAge; 大驼峰 int MyAge; 下划线 int my_age; 常见 Python 与 Linux 下 C&#x2F;C++ 开发 匈牙利 int iMyAge; 常见于 Windows 下 C&#x2F;C++ 开发，这个便于查看变量类型，但是现在的编译器做的都比较好，鼠标停留在上面就知道类型了 文件命名规范比如写的 .cpp、.h、.hpp 等 这些文件尽量用小写，多个单词可以用下划线（_）或者 连字符（-）连接，不应缩写，下划线比较通用。 文件名采用 下划线命名法 类型命名规范类型包括 类 class TestCase {}; 结构体 struct TestCase {}; 类型定义 typedef std::map&lt;int, int&gt; IntMap; using 别名 using IntMap &#x3D; std::map&lt;int, int&gt;; 枚举类型 enum EnumColor {}; 类型模板参数 template&lt;class NameType, class AgeType&gt; 类型采用 大驼峰命名法 变量命名规范变量（包括函数参数）和数据成员名一律小写，单词之间可以下划线(_)连接，类的成员变量以下划线结尾，但结构体不需要以下划线结尾。 1234567891011121314151617int userage = 20;int user_age = 20;void CheckUserAge(int user_age) &#123; &#125;class MyClassTest &#123;private: int temp_value_; int _temp_value2; // 也可以先写_起到强调作用 int tempvalue_; int _tempvalue;&#125;;struct LinkedList &#123; int* next_node; int* previousnode;&#125;; 类变量名采用 下划线命名法加结尾下划线 or 结尾下划线法 结构体变量名采用 下划线命名法 or 全部小写 常量命名规范被声明为 const、constexpr的变量，或者在程序运行期间始终不变的，命名时以 k 开头。 1const int kDaysInAWeek = 7; 常量采用 k + 大驼峰命名法 函数命名规范函数采用 大驼峰命名法 函数命名需要可以从函数名中知道你在这个函数里做到什么操作。 1string GetUserName() &#123;&#125; 枚举变量命名规范枚举的值都是常量，所以也应遵守常量命名规范。 k + 大驼峰 宏的方式（全是大写加下划线 123456enum RainbowColor &#123; kRed = 1, kOrange = 2, kYellow = 3, //...&#125; 命名空间命名规范 大驼峰命名法 写在最后 无论你用哪种命名方法，归根到底还是要通俗易懂，见名知意。 这些命名规则都可能会被淘汰，但是这种原则是一直都存在的。","categories":[{"name":"编程规范","slug":"编程规范","permalink":"https://www.030215.xyz/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"命名规范","slug":"命名规范","permalink":"https://www.030215.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"}]},{"title":"1604.警告一小时内使用相同员工卡大于等于三次的人(中等)","slug":"LeetCode/1604. 警告一小时内使用相同员工卡大于等于三次的人","date":"2023-02-06T16:00:00.000Z","updated":"2023-02-07T11:01:17.211Z","comments":true,"path":"article/73006677.html","link":"","permalink":"https://www.030215.xyz/article/73006677.html","excerpt":"","text":"题目描述 1604. 警告一小时内使用相同员工卡大于等于三次的人力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。 给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。 使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 &quot;23:51&quot; 和 &quot;09:49&quot; 。 请你返回去重后的收到系统警告的员工名字，将它们按 字典序****升序 排序后返回。 请注意 &quot;10:00&quot; - &quot;11:00&quot; 视为一个小时时间范围内，而 &quot;23:51&quot; - &quot;00:10&quot; 不被视为一小时内，因为系统记录的是某一天内的使用情况。 示例 1： 123输入：keyName = [&quot;daniel&quot;,&quot;daniel&quot;,&quot;daniel&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;], keyTime = [&quot;10:00&quot;,&quot;10:40&quot;,&quot;11:00&quot;,&quot;09:00&quot;,&quot;11:00&quot;,&quot;13:00&quot;,&quot;15:00&quot;]输出：[&quot;daniel&quot;]解释：&quot;daniel&quot; 在一小时内使用了 3 次员工卡（&quot;10:00&quot;，&quot;10:40&quot;，&quot;11:00&quot;）。 示例 2： 123输入：keyName = [&quot;alice&quot;,&quot;alice&quot;,&quot;alice&quot;,&quot;bob&quot;,&quot;bob&quot;,&quot;bob&quot;,&quot;bob&quot;], keyTime = [&quot;12:01&quot;,&quot;12:00&quot;,&quot;18:00&quot;,&quot;21:00&quot;,&quot;21:20&quot;,&quot;21:30&quot;,&quot;23:00&quot;]输出：[&quot;bob&quot;]解释：&quot;bob&quot; 在一小时内使用了 3 次员工卡（&quot;21:00&quot;，&quot;21:20&quot;，&quot;21:30&quot;）。 示例 3： 12输入：keyName = [&quot;john&quot;,&quot;john&quot;,&quot;john&quot;], keyTime = [&quot;23:58&quot;,&quot;23:59&quot;,&quot;00:01&quot;]输出：[] 示例 4： 12输入：keyName = [&quot;leslie&quot;,&quot;leslie&quot;,&quot;leslie&quot;,&quot;clare&quot;,&quot;clare&quot;,&quot;clare&quot;,&quot;clare&quot;], keyTime = [&quot;13:00&quot;,&quot;13:20&quot;,&quot;14:00&quot;,&quot;18:00&quot;,&quot;18:51&quot;,&quot;19:30&quot;,&quot;19:49&quot;]输出：[&quot;clare&quot;,&quot;leslie&quot;] 提示： 1 &lt;= keyName.length, keyTime.length &lt;= 105 keyName.length == keyTime.length keyTime 格式为 “HH:MM” 。 保证 [keyName[i], keyTime[i]] 形成的二元对 互不相同 。 1 &lt;= keyName[i].length &lt;= 10 keyName[i] 只包含小写英文字母。 解题过程1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: // 转换时间 int convert(string time) &#123; int res = 0; int minues = (time[0] - &#x27;0&#x27;) * 10 + (time[1] - &#x27;0&#x27;); // 小时 int second = (time[3] - &#x27;0&#x27;) * 10 + (time[4] - &#x27;0&#x27;); // 分钟 return minues * 60 + second; &#125; // 判断 bool judge(vector&lt;int&gt;&amp; v) &#123; sort(v.begin(), v.end()); // 排序 for (int i = 2; i &lt; v.size(); ++i) &#123; // 每三个的第一个和最后一个进行比较 if (v[i] - v[i - 2] &lt;= 60) return true; &#125; return false; &#125; vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) &#123; map&lt;string, vector&lt;int&gt;&gt; map; // map 排序 vector&lt;string&gt; ret; // 返回容器 for (int i = 0; i &lt; keyName.size(); ++i) &#123; string name = keyName[i]; // 记录姓名 string time = keyTime[i]; // 记录时间 map[name].push_back(convert(time)); // 转换好的时间放到 map 容器中 &#125; for (auto&amp; KeyVal : map) &#123; if (judge(KeyVal.second)) &#123; ret.push_back(KeyVal.first); &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"使用 Obsidian 有感","slug":"Tools/使用 Obsidian 有感","date":"2023-01-31T16:00:01.000Z","updated":"2023-02-06T13:25:20.823Z","comments":true,"path":"article/1cd98177.html","link":"","permalink":"https://www.030215.xyz/article/1cd98177.html","excerpt":"","text":"前言这是使用了 Obsidian 将近一个月之后的感想。 对于这 Markdown 编辑器这方面，我觉的 Obsidian 做到十分优秀，并且其本身还是开源的，但是经过这段时间使用 ，我发现使用 Obsidian 记笔记并不适合我，尽管他在很多方面十分的优秀，但是在我手上他已经不再是一个让我写作的工具了。 Obsidian 的优势功能齐全作为一款 Markdown 编辑器，其本身该有的功能都有具备，左侧文章集合，右侧文章目录，这点比 Typora 复合式的文件和大纲要显得方便，很多快捷键可以自定义，而 Typora 修改起来相对麻烦，当然 Obsidian 也不光如此，甚至可以进行网页浏览，给界面加个时间、日历等，我觉这已经完全不是一个编辑器应做的。 插件丰富Obsidian 提供（不算提供）了大量的插件工具，其本身就是通过插件出名的，对于使用功能与工作效率方面上得到了很大的改善和提升，甚至有不少人在做相关插件的介绍与推荐。 强大的出链和回链这个功能是找到当前文章所提到的文章和提到当前文章的文章，看起来好绕，其实就是我在这面文章里写到了哪篇文章，哪篇文章里提到了我这篇文章，对于知识的链接汇总有很大帮助。 图谱其实我觉这个功能真的没啥用，但是也是一大特色吧￣へ￣ 在一个球形图谱去看关系找联系还不如刀了我(* ￣︿￣) Obsidian 的弊端无法直接打开md文件Obsidian 无法直接打开 md 文件，他就好比 vscode 一样，需要放到一个文件夹中，也就是一个库中，这就导致在打开 md 文件的时候必须创建一个文件夹的方式打开，而且里面还会有 Obsidian 原本的配置文件，我在写博客的时候这个配置文件就要让我多好几步去排除上传和以及备份。在库中打开这是他的一个致命弱点，但这也是没有办法，因为它本身有很多的依赖，提到依赖下面还有其相关的弊端。 依赖无法共享Obsidian 的依赖是放在当前存放 md 文件夹的库中的，这就导致，我在一个库中把所有设置全部完善好了，等后面再换一个库，结果就是一切重来，这里包括 自定义CSS、主题 、设置 以及 插件 等。如果想变成上一个库那样，你就需要用上一个库中的配置文件替换掉当前库的配置文件，或者重新设置… 格式上不够美观Obsidian 也是所见即所得的 Markdown 编辑器，但他并没有 Typora 的格式美观。 打个比方，Obsidian 的回车只有单行（也可以按两下(￣﹏￣；)），而 Typora 在这面却做到很好，不光是两个回车来作段落的区分，而且段内行间距也把控的很好，在文字较多的时候看着清晰明了，不至于眼花缭乱。 这个其实是可以通过 CSS 调整的，但是！我是来记笔记的不是来学 CSS 的，不是来调试的找问题的，这个过程很容易走火入魔，最后还发现很多 CSS 应用到全局的时候 编辑模式 和 阅读模式 两个模式下显示的不一样，还要分开写 CSS。 兼容性问题Obsidian 的很多功能实现，换一个软件打开效果可能就没了，这就意味着你想要看到想要的效果，就必须一直使用 Obsidian，迁移是一个很麻烦的过程。 分散精力由于 Obsidian 提供了太多的功能，导致原先的写作热情全部变成了折腾的热情了。 当然这点弊端可能是在我个人身上发生的，但不能保证没有像我一样的人，想写笔记，但又喜欢折腾的人。 写在最后这篇文章是用 Typora 写的，Obsidian 成也 插件 败也 插件。 最后我觉的 Obsidian 功能多、插件多、主题多，实则离简洁易用的 Markdown 编辑器越来越远，使用他的这个个月里，什么都可以自定义，遇到问题找插件，主题也可以自己写或者下载，折腾了很久，最后发现还是没有原先就为你准备好的 Typora 好用。想写内容没写多少，CSS 倒是精进了不少。 最后的最后，Obsidian 很漂亮、很优雅，但是！我会使用 Typora，不为别的，只为效率。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Obsidian","slug":"Obsidian","permalink":"https://www.030215.xyz/tags/Obsidian/"}]},{"title":"2325. 解密消息(简单)","slug":"LeetCode/2325. 解密消息","date":"2023-01-31T16:00:00.000Z","updated":"2023-02-01T06:59:20.724Z","comments":true,"path":"article/a7357e06.html","link":"","permalink":"https://www.030215.xyz/article/a7357e06.html","excerpt":"","text":"题目描述 2325. 解密消息给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下： 使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。 将替换表与普通英文字母表对齐，形成对照表。 按照对照表 替换 message 中的每个字母。 空格 &#39; &#39; 保持不变。 例如，key = &quot;***hap***p***y*** ***bo***y&quot;（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（&#39;h&#39; -&gt; &#39;a&#39;、&#39;a&#39; -&gt; &#39;b&#39;、&#39;p&#39; -&gt; &#39;c&#39;、&#39;y&#39; -&gt; &#39;d&#39;、&#39;b&#39; -&gt; &#39;e&#39;、&#39;o&#39; -&gt; &#39;f&#39;）。 返回解密后的消息。 示例 1： 1234输入：key = &quot;the quick brown fox jumps over the lazy dog&quot;, message = &quot;vkbs bs t suepuv&quot;输出：&quot;this is a secret&quot;解释：对照表如上图所示。提取 &quot;the quick brown fox jumps over the lazy dog&quot; 中每个字母的首次出现可以得到替换表。 示例 2： 1234输入：key = &quot;eljuxhpwnyrdgtqkviszcfmabo&quot;, message = &quot;zwx hnfx lqantp mnoeius ycgk vcnjrdb&quot;输出：&quot;the five boxing wizards jump quickly&quot;解释：对照表如上图所示。提取 &quot;eljuxhpwnyrdgtqkviszcfmabo&quot; 中每个字母的首次出现可以得到替换表。 提示： 26 &lt;= key.length &lt;= 2000 key 由小写英文字母及 &#39; &#39; 组成 key 包含英文字母表中每个字符（&#39;a&#39; 到 &#39;z&#39;）至少一次 1 &lt;= message.length &lt;= 2000 message 由小写英文字母和 &#39; &#39; 组成 解题过程12345678910111213141516171819class Solution &#123;public: string decodeMessage(string key, string message) &#123; char a = &#x27;a&#x27;; unordered_map&lt;char, char&gt; rules; for (char c : key) &#123; if (c != &#x27; &#x27; &amp;&amp; rules.count(c) == 0) &#123; rules[c] = a; ++a; &#125; &#125; for (char&amp; c : message) &#123; if (c != &#x27; &#x27;) &#123; c = rules[c]; &#125; &#125; return message; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2319. 判断矩阵是否是一个 X 矩阵(简单)","slug":"LeetCode/2319. 判断矩阵是否是一个 X 矩阵","date":"2023-01-30T16:00:00.000Z","updated":"2023-01-31T08:42:04.213Z","comments":true,"path":"article/1e8c5a8.html","link":"","permalink":"https://www.030215.xyz/article/1e8c5a8.html","excerpt":"","text":"题目描述 2319. 判断矩阵是否是一个 X 矩阵如果一个正方形矩阵满足下述 全部 条件，则称之为一个 X 矩阵 ： 矩阵对角线上的所有元素都 不是 0 矩阵中所有其他元素都是 0 给你一个大小为 n x n 的二维整数数组 grid ，表示一个正方形矩阵。如果 grid 是一个 X 矩阵 ，返回 true ；否则，返回 false 。 示例 1： 12345输入：grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]输出：true解释：矩阵如上图所示。X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。因此，grid 是一个 X 矩阵。 示例 2： 12345输入：grid = [[5,7,0],[0,3,1],[0,5,0]]输出：false解释：矩阵如上图所示。X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。因此，grid 不是一个 X 矩阵。 提示： n == grid.length == grid[i].length 3 &lt;= n &lt;= 100 0 &lt;= grid[i][j] &lt;= 105 解题过程题目比较简单，考察的点就是对角线的表达，对角线上不等于 0 ，不在对角线上等于 0 ，返回 true，否则返回 false 即可。 1234567891011121314151617class Solution &#123;public: bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int girdLength = grid.size(); for (int i = 0; i &lt; girdLength; ++i) &#123; for (int j = 0; j &lt; girdLength; ++j) &#123; if (i == j || i + j + 1 == girdLength) &#123; if (!grid[i][j]) return false; &#125; else &#123; if (grid[i][j]) return false; &#125; &#125; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1669.合并两个链表(中等)","slug":"LeetCode/1669.合并两个链表","date":"2023-01-29T16:00:00.000Z","updated":"2023-02-04T06:48:29.184Z","comments":true,"path":"article/54f169cc.html","link":"","permalink":"https://www.030215.xyz/article/54f169cc.html","excerpt":"","text":"题目描述 1669. 合并两个链表给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。 请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。 下图中蓝色边和节点展示了操作后的结果： 请你返回结果链表的头指针。 示例 1： 123输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]输出：[0,1,2,1000000,1000001,1000002,5]解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。 示例 2： 123输入：list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]输出：[0,1,1000000,1000001,1000002,1000003,1000004,6]解释：上图中蓝色的边和节点为答案链表。 提示： 3 &lt;= list1.length &lt;= 104 1 &lt;= a &lt;= b &lt; list1.length - 1 1 &lt;= list2.length &lt;= 104 解题过程普通方法123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) &#123; ListNode* nodeA = list1; for (int i = 0; i &lt; a - 1; ++i) nodeA = nodeA-&gt;next; ListNode* nodeB = nodeA-&gt;next; for (int i = 0; i &lt; b - a + 1; ++i) nodeB = nodeB-&gt;next; nodeA-&gt;next = list2; for (;list2-&gt;next != nullptr; list2 = list2-&gt;next); list2-&gt;next = nodeB; return list1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2315. 统计星号(简单)","slug":"LeetCode/2315. 统计星号","date":"2023-01-28T16:00:00.000Z","updated":"2023-02-03T09:01:38.314Z","comments":true,"path":"article/111ae7aa.html","link":"","permalink":"https://www.030215.xyz/article/111ae7aa.html","excerpt":"","text":"题目描述 2315. 统计星号给你一个字符串 s ，每 两个 连续竖线 &#39;|&#39; 为 一对 。换言之，第一个和第二个 &#39;|&#39; 为一对，第三个和第四个 &#39;|&#39; 为一对，以此类推。 请你返回 不在 竖线对之间，s 中 &#39;*&#39; 的数目。 注意，每个竖线 &#39;|&#39; 都会 恰好 属于一个对。 示例 1： 123456输入：s = &quot;l|*e*et|c**o|*de|&quot;输出：2解释：不在竖线对之间的字符加粗加斜体后，得到字符串：&quot;l|*e*et|c**o|*de|&quot; 。第一和第二条竖线 &#x27;|&#x27; 之间的字符不计入答案。同时，第三条和第四条竖线 &#x27;|&#x27; 之间的字符也不计入答案。不在竖线对之间总共有 2 个星号，所以我们返回 2 。 示例 2： 123输入：s = &quot;iamprogrammer&quot;输出：0解释：在这个例子中，s 中没有星号。所以返回 0 。 示例 3： 123输入：s = &quot;yo|uar|e**|b|e***au|tifu|l&quot;输出：5解释：需要考虑的字符加粗加斜体后：&quot;yo|uar|e**|b|e***au|tifu|l&quot; 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。 提示： 1 &lt;= s.length &lt;= 1000 s 只包含小写英文字母，竖线 &#39;|&#39; 和星号 &#39;*&#39; 。 s 包含 偶数 个竖线 &#39;|&#39; 。 解题过程1、暴力解法1234567891011class Solution &#123;public: int countAsterisks(string s) &#123; int flag, num = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &#x27;|&#x27;) ++flag; if (flag % 2 == 0 &amp;&amp; s[i] == &#x27;*&#x27;) ++num; &#125; return num; &#125;&#125;; C 指针方法12345678int countAsterisks(char * s)&#123; int num = 0,flag = 0; for (; *s != &#x27;\\0&#x27;; ++s) &#123; if (*s == &#x27;|&#x27;) ++flag; if (flag % 2 == 0 &amp;&amp; *s == &#x27;*&#x27;) ++num; &#125; return num;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2309. 兼具大小写的最好英文字母(简单)","slug":"LeetCode/2309. 兼具大小写的最好英文字母","date":"2023-01-27T16:00:00.000Z","updated":"2023-01-31T08:55:54.870Z","comments":true,"path":"article/dd4bbbc8.html","link":"","permalink":"https://www.030215.xyz/article/dd4bbbc8.html","excerpt":"","text":"题目描述 2309. 兼具大小写的最好英文字母给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。 最好 英文字母的大写和小写形式必须 都 在 s 中出现。 英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。 示例 1： 1234&gt;输入：s = &quot;lEeTcOdE&quot;&gt;输出：&quot;E&quot;&gt;解释：&gt;字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。 示例 2： 12345&gt;输入：s = &quot;arRAzFif&quot;&gt;输出：&quot;R&quot;&gt;解释：&gt;字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。&gt;注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。 示例 3： 1234&gt;输入：s = &quot;AbCdEfGhIjK&quot;&gt;输出：&quot;&quot;&gt;解释：&gt;不存在大写和小写形式都出现的字母。 提示： 1 &lt;= s.length &lt;= 1000 s 由小写和大写英文字母组成 解题过程123456789101112class Solution &#123;public: string greatestLetter(string s) &#123; unordered_set&lt;char&gt; hash(s.begin(), s.end()); for (int i = 25; i &gt;= 0; --i) &#123; if (hash.count(&#x27;a&#x27; + i) &gt; 0 &amp;&amp; hash.count(&#x27;A&#x27; + i) &gt; 0) &#123; return string(1, &#x27;A&#x27; + i); &#125; &#125; return &quot;&quot;; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"876. 链表的中间结点(简单)","slug":"LeetCode新手村/876. 链表的中间结点","date":"2023-01-26T16:00:00.000Z","updated":"2023-01-31T08:55:47.739Z","comments":true,"path":"article/23908.html","link":"","permalink":"https://www.030215.xyz/article/23908.html","excerpt":"","text":"题目描述 876. 链表的中间结点给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 解题过程方法 112345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* currentNode = head; int listLength = 0; for (; currentNode != nullptr; currentNode = currentNode-&gt;next)&#123; ++listLength; &#125; currentNode = head; for (int i = 0; i &lt; listLength / 2; i++)&#123; currentNode = currentNode-&gt;next; &#125; return currentNode; &#125;&#125;; 方法 2快慢指针 使用双指针，指针1每次移动两个指针大小，指针2每次移动一个指针大小，指针1到 nullptr之后 指针2就在中间的位置 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* fastPtr = head; ListNode* slowPtr = head; while (fastPtr != nullptr &amp;&amp; fastPtr-&gt;next != nullptr)&#123; fastPtr = fastPtr-&gt;next-&gt;next; slowPtr = slowPtr-&gt;next; &#125; return slowPtr; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1664. 生成平衡数组的方案数(中等)","slug":"LeetCode/1664. 生成平衡数组的方案数","date":"2023-01-25T16:00:00.000Z","updated":"2023-02-06T13:27:04.154Z","comments":true,"path":"article/24712d21.html","link":"","permalink":"https://www.030215.xyz/article/24712d21.html","excerpt":"","text":"题目描述 1664. 生成平衡数组的方案数给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。 比方说，如果 nums = [6,1,7,4,1] ，那么： 选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。 选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。 选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。 如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。 请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。 示例 1： 12345678输入：nums = [2,1,6,4]输出：1解释：删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。只有一种让剩余数组成为平衡数组的方案。 示例 2： 123输入：nums = [1,1,1]输出：3解释：你可以删除任意元素，剩余数组都是平衡数组。 示例 3： 123输入：nums = [1,2,3]输出：0解释：不管删除哪个元素，剩下数组都不是平衡数组。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 解题过程1、暴力解法123456789101112131415161718class Solution &#123;public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) &#123; int num = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; vector&lt;int&gt; v = nums; v.erase(v.begin() + i); int length = v.size(); int sum1 =0, sum2 = 0; for (int j = 0; j &lt; length; ++j) &#123; if (j % 2 == 0) sum1 += v[j]; else sum2 += v[j]; &#125; if (sum1 == sum2) ++num; &#125; return num; &#125;&#125;; hhh 直接超时了 2、动态规划","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1480. 一维数组的动态和(简单)","slug":"LeetCode新手村/1480. 一维数组的动态和","date":"2023-01-24T16:00:00.000Z","updated":"2023-01-28T11:14:55.243Z","comments":true,"path":"article/45719.html","link":"","permalink":"https://www.030215.xyz/article/45719.html","excerpt":"","text":"新年第一道题，找个简单的(¬_¬ ) 题目描述 1480. 一维数组的动态和给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 123&gt;输入：nums = [1,2,3,4]&gt;输出：[1,3,6,10]&gt;解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 123&gt;输入：nums = [1,1,1,1,1]&gt;输出：[1,2,3,4,5]&gt;解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 12&gt;输入：nums = [3,1,2,10,1]&gt;输出：[3,4,6,16,17] 提示： 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 解题过程方法 1所求数组的每一位是所给数组的这个位置前面的数字（包括当前位置）累加的和 新建一个数组，用一个整形去存放累加和，放到新数组，这样数据多的时候比较耗内存，但是只用遍历一次，空间换时间 12345678910111213class Solution &#123;public: vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), sum = 0; vector&lt;int&gt; v(n); // 初始化 n 个空间 sum = v[0] = nums[0]; // 第一个数是不变的 for (int i = 1; i &lt; n; i++) &#123; sum += nums[i]; // 累加 v[i] = sum; &#125; return v; &#125;&#125;; 方法 2上面的方法在如果给定数组长度很长，这样的做法是很费空间的，其实也可以写成单个数组的形式，直接在已给数组上进行操作 index(1) &#x3D; index(1) + index(0) index(2) &#x3D; index(2) + index(1) index(3) &#x3D; index(3) + index(2) 有点递归的感觉 12345678class Solution &#123;public: vector&lt;int&gt; runningSum1(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); i++) nums[i] += nums[i - 1]; // 相加的结果之后进行累加 return nums; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"26. 删除有序数组中的重复项(简单)","slug":"LeetCode新手村/26.删除有序数组中的重复项","date":"2023-01-24T16:00:00.000Z","updated":"2023-01-28T11:12:52.127Z","comments":true,"path":"article/4154.html","link":"","permalink":"https://www.030215.xyz/article/4154.html","excerpt":"","text":"题目描述 26. 删除有序数组中的重复项给你一个 升序排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 升序 排列 解题过程1、暴力解法题目要求在原数组上进行修改，不能使用新空间去存储 下面是第一次写代码 123456789class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; for (int i = 1; i &lt; nums.size(); ++i) if (nums[i] == nums[i - 1]) nums.erase(nums.begin()+i); return nums.size(); &#125;&#125;; 调用的类方法去做，然而案例2都没过去 案例2：[0,0,1,1,1,2,2,3,3,4] 结果：[0,1,1,2,3,4] 不知道为什么多出来了个 1，忽略调用 erase 删除元素之后，后面元素的下标也会跟着改变 当一个数重复出现奇数次的时候，就会保留两个 所以这里需要对 nums[i] == nums[i - 1] 再次判断 下面修改后的代码 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return nums.size(); // 一个数就没必要继续 for (int i = 1; i &lt; nums.size(); ++i) if (nums[i] == nums[i - 1]) &#123; nums.erase(nums.begin()+i); --i; // 删除元素后对 i 进行减 1 &#125; return nums.size(); &#125;&#125;; 耗时击败 5% (╯°□°）╯︵ ┻━┻) 没太注意题目，题目说不需要考虑数组中超出新长度后面的元素。 所以这里还可以优化，不用删除重复的元素 12345678910111213class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return nums.size(); int index = 0; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[index] != nums[i])&#123; nums[++index] = nums[i]; &#125; &#125; return ++index; &#125;&#125;; 2、双指针双指针方法 12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return nums.size(); int p = 0; int q = 1; while (q &lt; nums.size()) &#123; if (nums[p] != nums[q]) &#123; nums[p + 1] = nums[q]; ++p; &#125; ++q; &#125; return p + 1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"1342. 将数字变成 0 的操作次数(简单)","slug":"LeetCode新手村/1342. 将数字变成 0 的操作次数","date":"2023-01-23T16:00:00.000Z","updated":"2023-01-28T11:12:14.991Z","comments":true,"path":"article/17862.html","link":"","permalink":"https://www.030215.xyz/article/17862.html","excerpt":"","text":"题目描述 1342. 将数字变成 0 的操作次数给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。 示例 1： 123456789输入：num = 14输出：6解释：步骤 1) 14 是偶数，除以 2 得到 7 。步骤 2） 7 是奇数，减 1 得到 6 。步骤 3） 6 是偶数，除以 2 得到 3 。步骤 4） 3 是奇数，减 1 得到 2 。步骤 5） 2 是偶数，除以 2 得到 1 。步骤 6） 1 是奇数，减 1 得到 0 。 示例 2： 1234567输入：num = 8输出：4解释：步骤 1） 8 是偶数，除以 2 得到 4 。步骤 2） 4 是偶数，除以 2 得到 2 。步骤 3） 2 是偶数，除以 2 得到 1 。步骤 4） 1 是奇数，减 1 得到 0 。 示例 3： 12输入：num = 123输出：12 提示： 0 &lt;= num &lt;= 10^6 解题过程方法 1使用递归方法，不知道为什么明明 执行代码 的输出结果是对的，提交之后输出结果就是错的 错误原因是因为使用了一个不该使用的 static ，使用静态变量，力扣大概会对这个类的方法重复使用比如说 所以这里不能使用 static关键字 123456789101112131415class Solution &#123;public: int numberOfSteps(int num) &#123; if (num == 0) return sum; if (num % 2 == 0) &#123; num /= 2;++sum; return numberOfSteps(num); &#125; else &#123; num -= 1;++sum; return numberOfSteps(num); &#125; &#125; int sum = 0;&#125;; 方法 2对于有 除 2 相关的操作，我们可以使用 位运算 来加快执行用时，用 while 来做判断依据 123456789101112class Solution &#123;public: int numberOfSteps(int num) &#123; int count = 0; while (num)&#123; if (num % 2 == 0) num &gt;&gt;= 1; else --num; ++count; &#125; return count; &#125;&#125;; 对于一些简单问题，可以先进行解题，然后再在其基础上进行优化如二维优化一维、是否可以在已给数据上进行操作、是否可以用逆向、是否可以用递归或者位运算等等","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"383. 赎金信(简单)","slug":"LeetCode新手村/383. 赎金信","date":"2023-01-23T16:00:00.000Z","updated":"2023-01-28T11:12:54.218Z","comments":true,"path":"article/51782.html","link":"","permalink":"https://www.030215.xyz/article/51782.html","excerpt":"","text":"题目描述 383. 赎金信给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 解题过程先对后面的字符串进行挨个计数，把每一个出现的字母所对应的位置进行递增操作 再对第一个字符串进行遍历，出现一个字符就对数组中的这个计数进行递减操作 当出现数组中的计数出现负数的时候，就说明第一个字符串包含的单个字母的个数较多，第二个字符串内的字符无法组成第一个字符串 12345678910111213class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.size() &gt; magazine.size()) return false; vector&lt;int&gt; v(26); for (auto&amp; c : magazine) v[c - &#x27;a&#x27;]++; for (auto&amp; c : ransomNote) &#123; v[c - &#x27;a&#x27;]--; if (v[c - &#x27;a&#x27;] &lt; 0) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"412. Fizz Buzz(简单)","slug":"LeetCode新手村/412. Fizz Buzz","date":"2023-01-22T16:00:00.000Z","updated":"2023-01-28T11:12:56.370Z","comments":true,"path":"article/5048.html","link":"","permalink":"https://www.030215.xyz/article/5048.html","excerpt":"","text":"题目描述 412. Fizz Buzz给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == &quot;FizzBuzz&quot; 如果 i 同时是 3 和 5 的倍数。 answer[i] == &quot;Fizz&quot; 如果 i 是 3 的倍数。 answer[i] == &quot;Buzz&quot; 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。 示例 1： 12输入：n = 3输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;] 示例 2： 12输入：n = 5输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;] 示例 3： 12输入：n = 15输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;] 提示： 1 &lt;= n &lt;= 104 解题过程12345678910111213class Solution &#123;public: vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; v; for (int i = 1; i &lt;= n; ++i) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) v.push_back(&quot;FizzBuzz&quot;); else if (i % 3 == 0) v.push_back(&quot;Fizz&quot;); else if (i % 5 == 0) v.push_back(&quot;Buzz&quot;); else v.push_back(to_string(i)); &#125; return v; &#125;&#125;; c语言写出来有点麻烦，注意二维数组需要进行指定空间和用 sprintf 函数向数组写入整形字符 12345678910111213char ** fizzBuzz(int n, int* returnSize)&#123; char** answer = (char**)malloc(sizeof(char*)*n); char* str = (char*)malloc(sizeof(char)*9*n); // 最长 9n for (int i = 0; i &lt; n; ++i) answer[i] = &amp;str[9*i]; // 指定空间 for (int i = 1; i &lt;= n; ++i) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) strcpy(answer[i -1], &quot;FizzBuzz&quot;); else if (i % 3 == 0) strcpy(answer[i - 1], &quot;Fizz&quot;); else if (i % 5 == 0) strcpy(answer[i - 1], &quot;Buzz&quot;); else sprintf(answer[i - 1], &quot;%d&quot;, i); &#125; *returnSize = n; return answer;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2303. 计算应缴税款总额(简单)","slug":"LeetCode/2303. 计算应缴税款总额","date":"2023-01-21T16:00:00.000Z","updated":"2023-01-28T11:11:24.565Z","comments":true,"path":"article/50305.html","link":"","permalink":"https://www.030215.xyz/article/50305.html","excerpt":"","text":"题目描述 2303. 计算应缴税款总额给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 &lt; i &lt; brackets.length 的前提下，upperi-1 &lt; upperi）。 税款计算方式如下： 不超过 upper0 的收入按税率 percent0 缴纳 接着 upper1 - upper0 的部分按税率 percent1 缴纳 然后 upper2 - upper1 的部分按税率 percent2 缴纳 以此类推 给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。 示例 1： 1234567输入：brackets = [[3,50],[7,10],[12,25]], income = 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。 示例 2： 123456输入：brackets = [[1,0],[4,25],[5,50]], income = 2输出：0.25000解释：前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。需要支付的税款总计 $0 + $0.25 = $0.25 。 示例 3： 1234输入：brackets = [[2,50]], income = 0输出：0.00000解释：没有收入，无需纳税，需要支付的税款总计 $0 。 提示： 1 &lt;= brackets.length &lt;= 100 1 &lt;= upperi &lt;= 1000 0 &lt;= percenti &lt;= 100 0 &lt;= income &lt;= 1000 upperi 按递增顺序排列 upperi 中的所有值 互不相同 最后一个税级的上限大于等于 income 解题过程方法 1不知道这个 income 到底位于这个二维数组的那个区间，所以可以使用比较笨的方法(～￣(OO)￣)ブ（二分好像也可以），直接遍历，每遍历完一遍记录以下当前值的前面一个 税级 ，当遇到income不大于税级的时候执行收入 - 税级 * 税率，退出循环，否则就是（当前税级 - 上一个税级） * 当前税率，并更新最后一个比收益小的税级 12345678910111213141516171819class Solution &#123;public: double calculateTax(vector&lt;vector&lt;int&gt;&gt;&amp; brackets, int income) &#123; double tax = 0; int x = 0; // 最后一个比收益小的税级 int n = brackets.size(); for (int i = 0; i &lt; n; i++) &#123; if (income &lt;= brackets[i][0]) &#123; tax += (income - x) * brackets[i][1]; break; &#125; else &#123; tax += (brackets[i][0] - x) * brackets[i][1]; x = brackets[i][0]; // 更新前一个税级 &#125; &#125; return tax / 100.0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"2299. 强密码检验器 II(简单)","slug":"LeetCode/2299. 强密码检验器 II","date":"2023-01-20T16:00:00.000Z","updated":"2023-01-28T11:11:14.444Z","comments":true,"path":"article/20129.html","link":"","permalink":"https://www.030215.xyz/article/20129.html","excerpt":"","text":"题目描述 2299. 强密码检验器 II如果一个密码满足以下所有条件，我们称它是一个 强 密码： 它有至少 8 个字符。 至少包含 一个小写英文 字母。 至少包含 一个大写英文 字母。 至少包含 一个数字 。 至少包含 一个特殊字符 。特殊字符为：&quot;!@#$%^&amp;*()-+&quot; 中的一个。 它 不 包含 2 个连续相同的字符（比方说 &quot;aab&quot; 不符合该条件，但是 &quot;aba&quot; 符合该条件）。 给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。 示例 1： 123&gt;输入：password = &quot;IloveLe3tcode!&quot;&gt;输出：true&gt;解释：密码满足所有的要求，所以我们返回 true 。 示例 2： 123&gt;输入：password = &quot;Me+You--IsMyDream&quot;&gt;输出：false&gt;解释：密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。 示例 3： 123&gt;输入：password = &quot;1aB!&quot;&gt;输出：false&gt;解释：密码不符合长度要求。所以我们返回 false 。 提示： 1 &lt;= password.length &lt;= 100 password 包含字母，数字和 &quot;!@#$%^&amp;*()-+&quot; 这些特殊字符。 解题过程题目较为简单，题目中的密码要求也很有意思，特殊字符正好是键盘上数字那一排，由于对 ASCII 码不太熟悉，我以为会有什么规律，结果规律并不明显 123456789101112! 33@ 64# 35$ 36% 37^ 94&amp; 38* 42( 40) 41- 45+ 43 于是就干脆使用 switch 进行选择了 以下是我第一次做的时候的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class solution &#123;public: bool strongPasswordCheckerII(string password) &#123; int len = password.length(); if (len &lt; 8) return false; // 至少包含一个，反面一个都没有 short daxie = 0; short xiaoxie = 0; short shuzi = 0; short teshu = 0; int length = len; for (int i = 0; i &lt; length; i++) &#123; if (i != 0 &amp;&amp; password[i] == password[i - 1]) return false; if (password[i] &gt;= &#x27;A&#x27; &amp;&amp; password[i] &lt;= &#x27;Z&#x27;) &#123; daxie++; continue; &#125; if (password[i] &gt;= &#x27;a&#x27; &amp;&amp; password[i] &lt;= &#x27;z&#x27;) &#123; xiaoxie++; continue; &#125; if (password[i] &gt;= &#x27;0&#x27; &amp;&amp; password[i] &lt;= &#x27;9&#x27;) &#123; shuzi++; continue; &#125; switch (password[i]) &#123; case &#x27;!&#x27;: teshu++; continue; case &#x27;@&#x27;: teshu++; continue; case &#x27;#&#x27;: teshu++; continue; case &#x27;$&#x27;: teshu++; continue; case &#x27;%&#x27;: teshu++; continue; case &#x27;^&#x27;: teshu++; continue; case &#x27;&amp;&#x27;: teshu++; continue; case &#x27;*&#x27;: teshu++; continue; case &#x27;(&#x27;: teshu++; continue; case &#x27;)&#x27;: teshu++; continue; case &#x27;-&#x27;: teshu++; continue; case &#x27;+&#x27;: teshu++; continue; &#125; &#125; if (daxie != 0 &amp;&amp; xiaoxie != 0 &amp;&amp; teshu != 0 &amp;&amp; shuzi != 0) return true; else return false; &#125;&#125;; 不得不说写的很繁琐，但运行是过了，不知道为什么耗时 0ms ，应该是卡了吧(ToT)&#x2F;~~~","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"Typora 快捷键","slug":"Tools/Typora快捷键","date":"2023-01-20T16:00:00.000Z","updated":"2023-01-28T11:10:13.813Z","comments":true,"path":"article/41636.html","link":"","permalink":"https://www.030215.xyz/article/41636.html","excerpt":"","text":"记载常用的即可（又不常用的(～￣▽￣)～ 文件 新建：ctrl+N 新建窗口：ctrl+shift+N 打开：ctrl+O（以文件的形式） 快速打开：ctrl+P（当前目录下的所有 .md 文件快速打开） 另存为：ctrl+shift+S 关闭：ctrl+W 编辑 标题：ctrl+1/2/3/4/5/6 表格：ctrl+T 代码块：ctrl+shift+K 代码：ctrl+shift+ &#96; 公式快：ctrl+shift+M 引用：ctrl+shift+Q 有序列表：ctrl+shift+[(还是 - 更方便 有序列表：ctrl+shift+] 增加缩进：ctrl+] 减少缩进：ctrl+[ 加粗：ctrl+B 斜体：ctrl+I 下划线：ctrl+U 超链接：ctrl+K 图像：ctrl+shift+I 视图 侧边栏隐藏：ctrl+shift+L 大纲视图：ctrl+shift+1 文档列表视图：ctrl+shift+2 文件树视图：ctrl+shift+3 源代码模式：ctrl+/ 专注模式：F8 打字机模式：F9 切换全屏：F11 实际大小：ctrl+shift+0 放大：ctrl+shift+= 缩小：ctrl+shift+- 应用内打开窗口：ctrl+Tab 打开DevTools：shift+F12 外加一点外 1234561. 带 &#123;% u 下划线 %&#125; 的文本2. 带 &#123;% emp 着重号 %&#125; 的文本3. 带 &#123;% wavy 波浪线 %&#125; 的文本4. 带 &#123;% del 删除线 %&#125; 的文本5. 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;6. 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://www.030215.xyz/tags/Typora/"}]},{"title":"1828. 统计一个圆中点的数目(中等)","slug":"LeetCode/1828. 统计一个圆中点的数目","date":"2023-01-19T16:00:00.000Z","updated":"2023-01-28T11:11:06.174Z","comments":true,"path":"article/62886.html","link":"","permalink":"https://www.030215.xyz/article/62886.html","excerpt":"","text":"题目描述 1828. 统计一个圆中点的数目给你一个数组 points ，其中 points[i] = [xi, yi] ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。 同时给你一个数组 queries ，其中 queries[j] = [xj, yj, rj] ，表示一个圆心在 (xj, yj) 且半径为 rj 的圆。 对于每一个查询 queries[j] ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。 请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。 示例 1： 1234输入：points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]输出：[3,2,2]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。 示例 2： 1234输入：points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]输出：[2,3,2,4]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆，queries[3] 是紫色的圆。 提示： 1 &lt;= points.length &lt;= 500 points[i].length == 2 0 &lt;= xi, yi &lt;= 500 1 &lt;= queries.length &lt;= 500 queries[j].length == 3 0 &lt;= xj, yj &lt;= 500 1 &lt;= rj &lt;= 500 所有的坐标都是整数。 解题过程点在圆内的公式 (x1 - x2)^2 - (y1 - y2)^2 &lt; r^2 ，注意题目说在圆上也算 循环圆的个数，在当前圆内对每一个点进行判断即可 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; // 判定一个圆内有几个点（包括圆上），points代表点（x1，y1），queries代表圆（x2，y2，半径） // 创建一个数组容器 vector&lt;int&gt; retV; // 创建一个圆的数量的大小的容器 // (x1 - x2)^2 + (y1 - y2)^2 &lt; r^2 点在圆内公式 for (auto&amp; querie : queries) &#123; int num = 0; // 在圆内的个数 for (auto&amp; point : points) &#123; if (pow(point[0] - querie[0], 2) + pow(point[1] - querie[1], 2) &lt;= pow(querie[2], 2)) &#123; ++num; &#125; &#125; retV.push_back(num); &#125; return retV; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"git 端口22失败问题","slug":"Tools/git端口错误","date":"2023-01-19T16:00:00.000Z","updated":"2023-01-28T11:10:06.233Z","comments":true,"path":"article/24454.html","link":"","permalink":"https://www.030215.xyz/article/24454.html","excerpt":"","text":"解决报错问题方法1 打开 windows 防火墙，高级设置 新建入站规则 选择端口 新建特定端口，写入 22 之后保存 方法2使用的网络有问题，使用别的网络试一下 这个问题困扰了我很长时间，每次再用 git 进行提交的时候总是显示没有权限，和端口请求失败，以至于想放弃使用 ssh，其实也可以使用 https 的方式去推送和拉取代码","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.030215.xyz/tags/git/"}]},{"title":"1824. 最少侧跳次数(中等)","slug":"LeetCode/1824.最少侧跳数","date":"2023-01-18T16:00:00.000Z","updated":"2023-01-28T11:10:56.620Z","comments":true,"path":"article/35387.html","link":"","permalink":"https://www.030215.xyz/article/35387.html","excerpt":"","text":"题目描述 1824. 最少侧跳次数给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。 给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。 比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。 这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。 比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。 这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。 注意：点 0 处和点 n 处的任一跑道都不会有障碍。 示例 1： 1234&gt;输入：obstacles = [0,1,2,3,0]&gt;输出：2 &gt;解释：最优方案如上图箭头所示。总共有 2 次侧跳（红色箭头）。&gt;注意，这只青蛙只有当侧跳时才可以跳过障碍（如上图点 2 处所示）。 示例 2： 123&gt;输入：obstacles = [0,1,1,3,3,0]&gt;输出：0&gt;解释：跑道 2 没有任何障碍，所以不需要任何侧跳。 示例 3： 123&gt;输入：obstacles = [0,2,1,0,3,0]&gt;输出：2&gt;解释：最优方案如上图所示。总共有 2 次侧跳。 提示： obstacles.length == n + 1 1 &lt;= n &lt;= 5 * 105 0 &lt;= obstacles[i] &lt;= 3 obstacles[0] == obstacles[n] == 0 解题过程1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) &#123; // 记录数组长度 int n = obstacles.size(); int INF = 0x3f3f3f3f; // 方便寻找没有障碍的跑道 int way[3][2] = &#123; &#123;1, 2&#125;, &#123;0, 2&#125; , &#123;0, 1&#125; &#125;; // 当前路线到零一路线最少次数 int f[3]; f[0] = 1; f[1] = 0; f[2] = 1; // 默认在中间一排 // one、two 表示没有阻碍的两条跑道 // w 表示有障碍的道路 int one = 0, two = 1, w = 2; // 随意初始化 // 从 1 开始遍历 obstacles for (int i = 1; i &lt; n; i++) &#123; // 没有障碍 if (obstacles[i] == 0) &#123; // 使用上一次的数据更新之前有障碍的跑道 f[w] = min(f[one], f[two]) + 1; continue; &#125; w = obstacles[i] - 1; f[w] = INF; one = way[w][0]; two = way[w][1]; f[one] = min(f[one], f[two] + 1); f[two] = min(f[one] + 1, f[two]); &#125; return min(min(f[0], f[1]), f[2]); &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"vika + PicGo 图床搭建","slug":"Tools/图床搭建","date":"2023-01-18T16:00:00.000Z","updated":"2023-02-04T06:06:43.121Z","comments":true,"path":"article/38401.html","link":"","permalink":"https://www.030215.xyz/article/38401.html","excerpt":"","text":"前言 原先使用 GitHub + PicGo 的方式搭建图床，显示效果不好，一张几百kb的照片需要加载四五秒，由于开了图片懒加载所以没显示图片的这个期间，图片哪里就是空白的，所以直接弃用 GitHub 搭建图床的方式，选用有国内服务器的 vika，使用起来也比 GitHub 稍微简单一点，最主要的是对于代理是没有要求的，原先使用 GitHub 作图床时，需要关闭代理，否则上传只会失败，而我使用git又需要代理，开来开去好麻烦(￣﹏￣；) 注册 vika vika 链接：https://vika.cn/?inviteCode=55298644 注册进入后，点击左侧控制台，进入工作目录，点击加号新建空白维格表 点击左下角头像选择个人设置，进入开发者配置 第一次进去是一个加号，点击加号，会进行绑定邮箱操作，绑定之后，回到刚刚新建表格找到 API 进入 API 选项，点击Get 获取，复制下面datasheets后面两个/之间的一串字母，这个是 维格表ID，再复制Bearer后面的一串字符，这个是token，后期也可以在开发者配置中去复制 PicGo 下载 PicGo (github.com) PicGo 需要插件才支持 vika，到插件设置去下载 记得在PicGo设置中打开vika 在图床设置中打开vika维格表 API Token 填写上面复制的 token 即可 维格表ID填写上面复制的datasheets后面的内容 其余内容可以默认，最后别忘了点击确定 此时就可以在上传区上传图片 PicGo 搭配 Typora 使用Typora 网盘链接： 链接：https://pan.baidu.com/s/1gVErYFgH7OROigXSAy_CPw?pwd=n4bc提取码：n4bc解压码：3215 在 Typora 软件中找到文件进入偏好设置点击图像 插入图片选择上传图片下面的勾选 上传服务选择PicGo(app)，下面填写他的安装路径即可 这个时候就可以在 Typora 中粘贴图片的时候，图片自己上传到vika并生成 URL 链接 压缩图片图片的大小会影响其加载速度，所以在保证图片质量的前提下，尽可能的减小图片内存大小 使用工具 Caesium - Image Compressor (软件) TinyPNG – Compress(网站)","categories":[{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://www.030215.xyz/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"博客备份和迁移","slug":"Blog/博客备份和迁移","date":"2023-01-17T16:00:00.000Z","updated":"2023-02-06T13:28:47.629Z","comments":true,"path":"article/53348.html","link":"","permalink":"https://www.030215.xyz/article/53348.html","excerpt":"","text":"备份新建 GitHub 仓库，将本地网站文件通过 git 与 GitHub 相连接 在本地文件中右键打开 Git Bash Here 1git init 1git remote add origin git@github.com:用户名/仓库.git 在网站文件根目录下新建一个shell脚本，命名为 push.sh 复制一下内容进入脚本 1234567891011echo -e &quot;\\033[32m正在为你备份博客中.........\\033[0m&quot;git add .echo -e &quot;\\033[32m正在为你备份博客中.........\\033[0m&quot;git commit -m &quot;update&quot;echo -e &quot;\\033[32m正在为你备份博客中.........\\033[0m&quot;git push origin master --forceif [ $? -ne 0 ]; then echo -e &quot;\\033[31m 备份失败！请检查网络情况！ \\033[0m&quot;else echo -e &quot;\\033[32m恭喜你！已为你备份到你的GitHub仓库 backup \\033[0m&quot;fi 在网站文件右键打开 Git Bash Here 输入 ./push.sh 即可完成备份 两键上传加备份在桌面写一个 dp.sh.dat 名字随意，后缀 .bat ，文件写入以下内容 1cmd /k &quot;cd /d D:\\distake\\blog&amp;&amp;hexo cl&amp;&amp;hexo g&amp;&amp;gulp&amp;&amp;hexo d&amp;&amp;git add .&amp;&amp;git commit -m &quot;update&quot;&amp;&amp;git push origin master --force&quot; &#x2F;k 表示执行结束后不退出控制台，可以化成 &#x2F;cgulp 使用的前提是要有 gulp 包，并且添加一个 js 脚本，用于压缩文件 安装 gulp 12npm install gulp -gnpm install gulp-minify-html gulp-minify-css gulp-uglify gulp-imagemin --save 根目录下建立 gulpfile.js 文件，写入以下内容 12345678910111213141516171819202122232425262728293031323334353637383940var gulp = require(&#x27;gulp&#x27;);//Plugins模块获取var minifycss = require(&#x27;gulp-minify-css&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;);var htmlmin = require(&#x27;gulp-htmlmin&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);//压缩cssgulp.task(&#x27;minify-css&#x27;, function () &#123; return gulp.src(&#x27;./public/**/*.css&#x27;) .pipe(minifycss()) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//压缩htmlgulp.task(&#x27;minify-html&#x27;, function () &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);//压缩js 不压缩min.jsgulp.task(&#x27;minify-js&#x27;, function () &#123; return gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(uglify()) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);//4.0以前的写法 //gulp.task(&#x27;default&#x27;, [// &#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task(&#x27;default&#x27;, gulp.parallel(&#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, function (done) &#123; // Do something after a, b, and c are finished. done();&#125;)); 迁移第一步：安装 Hexo 环境 &#x2F; 工具 nodejs：Node.js (nodejs.org) git：Git - Downloads (git-scm.com) or 提供git(windows)下载 - 网达极客社区 (gitclone.com) 第二步：配置密钥信息在本地文件夹中输入以下指令，会生成密钥，需要到 GitHub 设置中去添加密钥（公钥 123ssh-keygen -t rsa -C &quot;邮箱&quot;git config --global user.name &quot;英文名字&quot;git config --global user.email &quot;邮箱&quot; 生成公钥的位置，在本地中 第三步：克隆仓库1git clone git@github.com:用户名/仓库.git 对 npm 进行安装 1npm install 至此，迁移完成 写在最后博客是一种记录的方式，最后希望这种方式依然长久","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"1817. 查找用户活跃分钟数(中等)","slug":"LeetCode/1817. 查找用户活跃分钟数","date":"2023-01-17T16:00:00.000Z","updated":"2023-02-03T09:12:10.100Z","comments":true,"path":"article/54870.html","link":"","permalink":"https://www.030215.xyz/article/54870.html","excerpt":"","text":"题目描述 1817. 查找用户活跃分钟数给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDi, timei] 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。 多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。 指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。 请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 &lt;= j &lt;= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。 返回上面描述的答案数组 answer 。 示例 1： 123456&gt;输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5&gt;输出：[0,2,0,0,0]&gt;解释：&gt;ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）&gt;ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2&gt;2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0 示例 2： 1234567&gt;输入：logs = [[1,1],[2,2],[2,3]], k = 4&gt;输出：[1,1,0,0]&gt;解释：&gt;ID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1&gt;ID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2&gt;1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2 &gt;因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0 提示： 1 &lt;= logs.length &lt;= 104 0 &lt;= IDi &lt;= 109 1 &lt;= timei &lt;= 105 k 的取值范围是 [用户的最大用户活跃分钟数, 105] 解题过程这个题刚开始读的时候有点懵(这个难道不是语文阅读吗ಠಿ_ಠ) 先从输出结果来看示例1中[0, 2, 0, 0, 0]answer[0] 表示活跃时长为1分钟的人有 0 人answer[1] 表示活跃时长为2分钟的人有 2 人answer[2] 表示活跃时长为3分钟的人有 0 人answer[3] 表示活跃时长为4分钟的人有 0 人answer[4] 表示活跃时长为5分钟的人有 0 人 这就是题目要求的数组，题目可以用 Hash 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) &#123; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; Minutes; for (auto&amp; log : logs) &#123; int i = log[0]; int time = log[1]; Minutes[i].insert(time); &#125; vector&lt;int&gt; answer(k); for (auto&amp; [_, ts] : Minutes) &#123; ++answer[ts.size() - 1]; &#125; return answer; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"}]},{"title":"hexo食用方法","slug":"Blog/hexo食用方法","date":"2023-01-15T16:00:00.000Z","updated":"2023-02-08T04:21:24.809Z","comments":true,"path":"article/46371.html","link":"","permalink":"https://www.030215.xyz/article/46371.html","excerpt":"","text":"文章设置 写法 解释 title 【必需】文章标题 date 【必需】文章创建日期 2022-12-12 updated 【可选】文章更新日期 tags 【可选】文章标籤 categories 【可选】文章分类 keywords 【可选】文章关键字 description 【可选】文章描述 top_img 【可选】文章顶部图片 cover 【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空) comments 【可选】显示文章评论模块(默认 true) toc 【可选】显示文章TOC(默认为设置中toc的enable配置) toc_number 【可选】显示toc_number(默认为设置中toc的number配置) toc_style_simple 【可选】显示 toc 简洁模式 copyright 【可选】显示文章版权模块(默认为设置中post_copyright的enable配置) copyright_author 【可选】文章版权模块的文章作者 copyright_author_href 【可选】文章版权模块的文章作者链接 copyright_url 【可选】文章版权模块的文章连结链接 copyright_info 【可选】文章版权模块的版权声明文字 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) katex 【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false) highlight_shrink 【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置) aside 【可选】显示侧边栏 (默认 true) sticky 填写数字，表示置顶 文章推送1234hexo cleanhexo ggulphexo d 脚本一行命令部署，根目录下新建 dp.sh 文件，写入以下内容，以后只需要在输入 ./dp.sh 即可完成部署加备份，hhh 123456789101112131415echo -e &quot;\\033[32mclear.........\\033[0m&quot;hexo clecho -e &quot;\\033[32mgenerate.........\\033[0m&quot;hexo gecho -e &quot;\\033[32mgulp.........\\033[0m&quot;gulpecho -e &quot;\\033[32mdeploy.........\\033[0m&quot;hexo decho -e &quot;\\033[32backup.........\\033[0m&quot;./push.shif [ $? -ne 0 ]; then echo -e &quot;\\033[31m fail,check your net \\033[0m&quot;else echo -e &quot;\\033[32msuccess deploy and backup\\033[0m&quot;fi 备份推送（有相关脚本以及仓库情况下 1./push.sh 文章标签外挂 以下内容仅 butterfly 主题支持，非必要不使用 折叠栏（Toggle） 代码 12345&#123;% hideToggle 点击打开 %&#125;这里可以写内容&#123;% endhideToggle %&#125; 预览 12345&#123;% hideToggle 点击打开 %&#125;这里可以写内容&#123;% endhideToggle %&#125; 选择卡（Tabs） 代码 1234567891011&#123;% tabs 样例 %&#125;&lt;!-- tab 内容1 --&gt;这里可以写内容&lt;!-- endtab --&gt;&lt;!-- tab 内容2 --&gt;这里可以写内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 预览 1234567&#123;% tabs 样例 %&#125;&lt;!-- tab 内容1 --&gt;这里可以写内容&lt;!-- endtab --&gt;&lt;!-- tab 内容2 --&gt;这里可以写内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125;","categories":[{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"失误","slug":"Blog/失误","date":"1999-12-31T16:00:00.000Z","updated":"2023-02-25T02:48:02.490Z","comments":true,"path":"article/1f25a47c.html","link":"","permalink":"https://www.030215.xyz/article/1f25a47c.html","excerpt":"","text":"2023年 2 月 25 日 晚 18:00~21:00 记录记一次失误，事情说大也不大，说小也不小。 实验室招人，我秉着势在必得的心态去计测了，题目大概中等水平，前面的题很难，后面的就稍微简单一些，十道题左右，我完全有把握的有四道，其他的不是很确定。这次报名人数很多，但是实际去计测的人没有多少，一个机房也就近十个人，还有一个机房，不清楚人数，应该也不多，本来想着能做出几道题就差不多了，应该能通过的，考完之后感觉信心十足。然而乌龙出现了，晚上想一道题的时候，想着想着，发现我犯了一个致命的错误，语言类型没换，默认 C，我用到 C++，这就意味着编译都通过不了，越想越气，一晚上没睡好，辗转反侧。 既然写到这里的，也有必要总结一下这次的经历与教训，其实没换语言只是失误之一。做题的时候心情太浮躁了，第一道题叫开心数，把我难住了，考的好像是贪心问题，我旁边坐着我的同班同学，是我班的学委，平时也和我玩的比较好，我听着他在键盘上劈里啪啦敲着，我开始慌乱了，不知过了多久这个题我还是没有好头绪，我就放弃了。开始下一题，第二题叫朋友圈，在草稿纸上研究也许久，也没有具体思路，然后我开始做第三题，第三题叫完美矩阵，这个题我觉得有思路，开始动手了，经过大概半小时的推敲，然后开始调试和测试，案例都通过之后交了上去，开始下一题，后面的题名字比较怪也不太记得了，我依稀记得我后面有把握的写出来了三题，中间的时候，我看了看同学写的，我看他调试出错了，然后不想写了，就直接交上去了，我说：“题好难啊”，“对呀，我一道都不会写”他这么回答的，我又问道：“那你写那么多”，“好多都是不对，乱写了”他笑着说，我看了看他写的代码，好像确实那么回事，我也笑了，然后开始觉得无所谓了，随便写了，精神也没有那么绷紧，期间他还问我了一些题目问题，我也是佩服自己居然还有时间给他讲，后面来了一道简单题，最后一题了，大概只剩下十分钟了，然后时间正好的差了一分钟左右，没交上。 有时候没有分清楚场合，也许把闲聊、沟通的时间多用在检查上面，没准就能找到很多 bug 所在，尤其是语言选择。 这次进实验室是没希望了，下次不知道是什么时候，也许也没有下一次了，但我会以我的方式学下去，即使身边没有同行的人。 愿我依能积极乐观的面对一切（摆ㄟ( ▔——▔ )ㄏ）。 纪一次似大非大的失误","categories":[],"tags":[]}],"categories":[{"name":"LeetCode必刷题","slug":"LeetCode必刷题","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"LeetCode必刷题/链表","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"},{"name":"编程随想","slug":"编程随想","permalink":"https://www.030215.xyz/categories/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/"},{"name":"数组","slug":"LeetCode必刷题/数组","permalink":"https://www.030215.xyz/categories/LeetCode%E5%BF%85%E5%88%B7%E9%A2%98/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/categories/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/categories/Python/"},{"name":"编程规范","slug":"编程规范","permalink":"https://www.030215.xyz/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"},{"name":"工具","slug":"工具","permalink":"https://www.030215.xyz/categories/%E5%B7%A5%E5%85%B7/"},{"name":"博客相关","slug":"博客相关","permalink":"https://www.030215.xyz/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.030215.xyz/tags/%E9%93%BE%E8%A1%A8/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://www.030215.xyz/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"模拟","slug":"模拟","permalink":"https://www.030215.xyz/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.030215.xyz/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","permalink":"https://www.030215.xyz/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分查找","slug":"二分查找","permalink":"https://www.030215.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"Python","slug":"Python","permalink":"https://www.030215.xyz/tags/Python/"},{"name":"命名规范","slug":"命名规范","permalink":"https://www.030215.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.030215.xyz/tags/LeetCode/"},{"name":"Obsidian","slug":"Obsidian","permalink":"https://www.030215.xyz/tags/Obsidian/"},{"name":"Typora","slug":"Typora","permalink":"https://www.030215.xyz/tags/Typora/"},{"name":"git","slug":"git","permalink":"https://www.030215.xyz/tags/git/"},{"name":"图床","slug":"图床","permalink":"https://www.030215.xyz/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"博客","slug":"博客","permalink":"https://www.030215.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]}